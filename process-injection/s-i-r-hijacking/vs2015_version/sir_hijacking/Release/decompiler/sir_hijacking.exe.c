//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct tagPROCESSENTRY32W {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int16_t e9[1];
};

struct tagTHREADENTRY32 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

// ------------------- Function Prototypes --------------------

int32_t function_401050(void);
int32_t function_4011b0(void);
int32_t function_4013c0(void);
int32_t function_4014a0(void);
int32_t function_401540(void);
int32_t function_401550(char * a1, int32_t * a2);
int32_t function_401580(void);
int32_t function_401590(char * a1);

// --------------------- Global Variables ---------------------

int32_t g1 = 10; // 0x403624
int32_t g2 = 10; // 0x4036d4
int32_t g3 = 0; // 0x405370
int32_t g4 = 0; // 0x405378
int32_t g5 = 0; // 0x405380
int32_t g6 = 0; // 0x405384
char * g7; // 0x405388
int32_t g8;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401047
int main(int argc, char ** argv) {
    // 0x401000
    function_401590("Which process are you looking for?\n");
    function_401550("%s", (int32_t *)&g7);
    function_4011b0();
    function_401590("Enter a pid:tid combination (hex form, without 0x)\n");
    function_401550("%x:%x", &g6);
    function_401050();
    return 0;
}

// Address range: 0x401050 - 0x4011a5
int32_t function_401050(void) {
    int32_t * hObject = CreateToolhelp32Snapshot(4, g6); // 0x401070
    if (hObject == (int32_t *)-1) {
        // 0x40107d
        function_401590("[FAIL] Failed to take thread snapshot!\n");
        return _40___security_check_cookie_40_4();
    }
    int32_t v1 = (int32_t)hObject; // 0x401070
    int32_t v2 = 28; // bp-36, 0x40109f
    int32_t v3; // bp-68, 0x401050
    if (!Thread32First(hObject, (struct tagTHREADENTRY32 *)&v2)) {
        // 0x4010b2
        v3 = (int32_t)"[FAIL] Couldn't retrieve an information for the first thread!\n";
        function_401590("[FAIL] Couldn't retrieve an information for the first thread!\n");
        function_4014a0();
        v3 = v1;
        CloseHandle(hObject);
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = &v3;
    int32_t v5 = v4; // 0x4010e6
    int32_t v6; // 0x401050
    int32_t v7; // 0x401050
    int32_t v8; // 0x4010fe
    int32_t * v9; // 0x401103
    int32_t * v10; // 0x401050
    int32_t v11; // 0x401103
    int32_t v12; // 0x401136
    int32_t v13; // 0x401050
    int32_t * v14; // 0x401050
    int32_t v15; // 0x401156
    if (v7 == g5) {
        // 0x4010ec
        *(int32_t *)(v4 - 4) = (int32_t)"[OK] Find\n";
        function_401590((char *)&g8);
        *(int32_t *)(v4 - 8) = 0;
        v8 = v4 - 12;
        *(int32_t *)v8 = 0x1fffff;
        v9 = OpenThread((int32_t)&g8, (bool)&g8, (int32_t)&g8);
        v10 = (int32_t *)(v4 - 16);
        if (v9 != NULL) {
            // 0x401128
            v11 = (int32_t)v9;
            *v10 = (int32_t)"[OK] Open\n";
            function_401590((char *)&g8);
            *v10 = v11;
            v12 = SuspendThread(&g8);
            v13 = v4 - 20;
            v14 = (int32_t *)v13;
            *v14 = v12 == -1 ? (int32_t)"[FAIL] Suspend\n" : (int32_t)"[OK] Suspend\n";
            function_401590((char *)&g8);
            *v14 = v11;
            v15 = ResumeThread(&g8);
            v6 = v15 == -1 ? (int32_t)"[FAIL] Resume\n" : (int32_t)"[OK] Resume\n";
            *(int32_t *)(v4 - 24) = v6;
            function_401590((char *)&g8);
            v5 = v13;
        } else {
            // 0x40110f
            *v10 = (int32_t)"[FAIL] Couldn't open the thread!\n";
            function_401590((char *)&g8);
            function_4014a0();
            v5 = v8;
        }
    }
    int32_t v16 = v5;
    *(int32_t *)(v16 - 4) = (int32_t)&v2;
    int32_t v17 = v16 - 8; // 0x401179
    *(int32_t *)v17 = v1;
    while (Thread32Next(&g8, (struct tagTHREADENTRY32 *)&g8)) {
        // 0x4010e3
        v4 = v17;
        v5 = v4;
        if (v7 == g5) {
            // 0x4010ec
            *(int32_t *)(v4 - 4) = (int32_t)"[OK] Find\n";
            function_401590((char *)&g8);
            *(int32_t *)(v4 - 8) = 0;
            v8 = v4 - 12;
            *(int32_t *)v8 = 0x1fffff;
            v9 = OpenThread((int32_t)&g8, (bool)&g8, (int32_t)&g8);
            v10 = (int32_t *)(v4 - 16);
            if (v9 != NULL) {
                // 0x401128
                v11 = (int32_t)v9;
                *v10 = (int32_t)"[OK] Open\n";
                function_401590((char *)&g8);
                *v10 = v11;
                v12 = SuspendThread(&g8);
                v13 = v4 - 20;
                v14 = (int32_t *)v13;
                *v14 = v12 == -1 ? (int32_t)"[FAIL] Suspend\n" : (int32_t)"[OK] Suspend\n";
                function_401590((char *)&g8);
                *v14 = v11;
                v15 = ResumeThread(&g8);
                v6 = v15 == -1 ? (int32_t)"[FAIL] Resume\n" : (int32_t)"[OK] Resume\n";
                *(int32_t *)(v4 - 24) = v6;
                function_401590((char *)&g8);
                v5 = v13;
            } else {
                // 0x40110f
                *v10 = (int32_t)"[FAIL] Couldn't open the thread!\n";
                function_401590((char *)&g8);
                function_4014a0();
                v5 = v8;
            }
        }
        // 0x401175
        v16 = v5;
        *(int32_t *)(v16 - 4) = (int32_t)&v2;
        v17 = v16 - 8;
        *(int32_t *)v17 = v1;
    }
    // 0x401188
    *(int32_t *)(v16 - 12) = v1;
    CloseHandle(&g8);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4011b0 - 0x4013b3
int32_t function_4011b0(void) {
    int32_t * hObject = CreateToolhelp32Snapshot(2, 0); // 0x4011c8
    if (hObject == (int32_t *)-1) {
        // 0x4011d5
        function_401590("[Error] Invalid handle value!\n");
        function_4014a0();
        return _40___security_check_cookie_40_4();
    }
    int32_t v1 = 556; // bp-564, 0x401203
    if (!Process32FirstW(hObject, (struct tagPROCESSENTRY32W *)&v1)) {
        // 0x401219
        function_401590("[Error] Failed to retrieve information for the first process!\n");
        function_4014a0();
        CloseHandle(hObject);
        return _40___security_check_cookie_40_4();
    }
    int32_t v2 = (int32_t)hObject; // 0x4011c8
    int32_t v3; // bp-528, 0x4011b0
    int32_t v4 = &v3; // 0x401255
    int32_t v5; // bp-592, 0x4011b0
    int32_t v6 = &v5; // 0x40124a
    int32_t * v7; // 0x4011b0
    int32_t * v8; // 0x4011b0
    int32_t v9; // 0x4011b0
    int32_t v10; // 0x4011b0
    while (true) {
      lab_0x401250:
        // 0x401250
        v9 = v6;
        int32_t v11 = (int32_t)&g7;
        int32_t v12 = v4;
        char v13 = *(char *)v12; // 0x401260
        while (v13 == *(char *)v11) {
            if (v13 == 0) {
                goto lab_0x40128d_2;
            }
            char v14 = *(char *)(v12 | 1); // 0x40126a
            if (v14 != *(char *)(v11 || 1)) {
                // break -> 0x401380
                break;
            }
            int32_t v15 = v12 + 2; // 0x40127a
            int32_t v16 = v11 + 2; // 0x40127a
            if (v14 == 0) {
                goto lab_0x40128d_2;
            }
            v11 = v16;
            v12 = v15;
            v13 = *(char *)v12;
        }
        int32_t v17 = v9 - 8; // 0x401387
        v8 = (int32_t *)v17;
        v6 = v17;
        v7 = (int32_t *)(v9 - 4);
        v10 = v9;
        goto lab_0x401380;
    }
  lab_0x401396:
    // 0x401396
    *(int32_t *)(v10 - 12) = v2;
    CloseHandle(&g8);
    return _40___security_check_cookie_40_4();
  lab_0x40128d_2:
    // 0x40128d
    *(int32_t *)(v9 - 4) = (int32_t)L"\n\n=====================================================";
    function_401590((char *)&g8);
    int32_t * v18 = (int32_t *)(v9 - 8); // 0x40129d
    *v18 = v4;
    int32_t v19 = v9 - 12; // 0x40129e
    int32_t * v20 = (int32_t *)v19; // 0x40129e
    *v20 = (int32_t)L"\nprocess:  %s";
    function_401590((char *)&g8);
    int32_t * v21 = (int32_t *)(v9 - 16); // 0x4012a8
    *v21 = (int32_t)L"\n------------------------------------------------------\n";
    function_401590((char *)&g8);
    *v18 = 0;
    *v20 = 0x1fffff;
    int32_t * v22 = OpenProcess((int32_t)&g8, (bool)&g8, (int32_t)&g8); // 0x4012c3
    int32_t v23; // 0x4011b0
    int32_t * v24; // 0x4011b0
    int32_t v25; // 0x4011b0
    int32_t v26; // 0x4011b0
    int32_t v27; // 0x4012c3
    int32_t v28; // 0x4012e9
    if (v22 != NULL) {
        // 0x4012e8
        v27 = (int32_t)v22;
        *v21 = v27;
        v28 = GetPriorityClass(&g8);
        v23 = v9 - 20;
        v24 = (int32_t *)v23;
        if (v28 != 0) {
            goto lab_0x40130c;
        } else {
            // 0x4012f5
            *v24 = (int32_t)"[Error] Couldn't get priority class!\n";
            function_401590((char *)&g8);
            function_4014a0();
            goto lab_0x40130c;
        }
    } else {
        // 0x4012cf
        *v21 = (int32_t)"[Error] Couldn't open the process!\n";
        function_401590((char *)&g8);
        function_4014a0();
        v26 = v19;
        v25 = 0;
        goto lab_0x401313;
    }
  lab_0x401380:
    // 0x401380
    *v7 = (int32_t)&v1;
    *v8 = v2;
    if (!Process32NextW(&g8, (struct tagPROCESSENTRY32W *)&g8)) {
        // break -> 0x401396
        goto lab_0x401396;
    }
    goto lab_0x401250;
  lab_0x40130c:
    // 0x40130c
    *v24 = v27;
    CloseHandle(&g8);
    v26 = v23;
    v25 = v28;
    goto lab_0x401313;
  lab_0x401313:;
    int32_t * v29 = (int32_t *)(v26 - 4);
    int32_t v30 = v26 - 8;
    int32_t * v31 = (int32_t *)v30;
    *v31 = (int32_t)L"\n  pid               = 0x%08X";
    function_401590((char *)&g8);
    *(int32_t *)(v26 - 16) = (int32_t)L"\n  # of threads      = %d";
    function_401590((char *)&g8);
    *(int32_t *)(v26 - 24) = (int32_t)L"\n  parent pid        = 0x%08X";
    function_401590((char *)&g8);
    *(int32_t *)(v26 - 32) = (int32_t)L"\n  prio base         = %d";
    function_401590((char *)&g8);
    if (v25 == 0) {
        goto lab_0x401368;
    } else {
        // 0x40135a
        *v29 = v25;
        *v31 = (int32_t)L"\n  prio class      = %d";
        function_401590((char *)&g8);
        goto lab_0x401368;
    }
  lab_0x401368:
    // 0x401368
    *v29 = (int32_t)&g1;
    function_401590((char *)&g8);
    function_4013c0();
    v8 = v31;
    v6 = v30;
    v7 = v29;
    v10 = v26;
    goto lab_0x401380;
}

// Address range: 0x4013c0 - 0x401498
int32_t function_4013c0(void) {
    int32_t * hObject = CreateToolhelp32Snapshot(4, 0); // 0x4013d8
    if (hObject == (int32_t *)-1) {
        // 0x4013e5
        function_401590("[Error] Failed to take thread snapshot!\n");
        return _40___security_check_cookie_40_4();
    }
    int32_t v1 = (int32_t)hObject; // 0x4013d8
    int32_t v2 = 28; // bp-36, 0x401407
    int32_t v3; // bp-64, 0x4013c0
    if (!Thread32First(hObject, (struct tagTHREADENTRY32 *)&v2)) {
        // 0x40141a
        v3 = (int32_t)"[Error] Couldn't retrieve an information for the first thread!\n";
        function_401590("[Error] Couldn't retrieve an information for the first thread!\n");
        function_4014a0();
        v3 = v1;
        CloseHandle(hObject);
        return _40___security_check_cookie_40_4();
    }
    int32_t v4 = &v3;
    int32_t v5; // 0x401474
    int32_t v6; // 0x4013c0
    int32_t * v7; // 0x4013c0
    int32_t v8; // 0x4013c0
    int32_t * v9; // 0x4013c0
    int32_t v10; // 0x4013c0
    int32_t v11; // 0x4013c0
    if (v10 != v8) {
        // 0x401451
        v5 = v4 - 8;
        v7 = (int32_t *)v5;
        v6 = v5;
    } else {
        // 0x401456
        v11 = v4 - 8;
        v9 = (int32_t *)v11;
        *v9 = (int32_t)L"    tid             = 0x%08X";
        function_401590((char *)&g8);
        *(int32_t *)(v4 - 12) = (int32_t)&g2;
        function_401590((char *)&g8);
        v7 = v9;
        v6 = v11;
    }
    // 0x401470
    *(int32_t *)(v4 - 4) = (int32_t)&v2;
    *v7 = v1;
    while (Thread32Next(&g8, (struct tagTHREADENTRY32 *)&g8)) {
        // 0x401451
        v4 = v6;
        if (v10 != v8) {
            // 0x401451
            v5 = v4 - 8;
            v7 = (int32_t *)v5;
            v6 = v5;
        } else {
            // 0x401456
            v11 = v4 - 8;
            v9 = (int32_t *)v11;
            *v9 = (int32_t)L"    tid             = 0x%08X";
            function_401590((char *)&g8);
            *(int32_t *)(v4 - 12) = (int32_t)&g2;
            function_401590((char *)&g8);
            v7 = v9;
            v6 = v11;
        }
        // 0x401470
        *(int32_t *)(v4 - 4) = (int32_t)&v2;
        *v7 = v1;
    }
    // 0x40147b
    *(int32_t *)(v4 - 12) = v1;
    CloseHandle(&g8);
    return _40___security_check_cookie_40_4();
}

// Address range: 0x4014a0 - 0x40153d
int32_t function_4014a0(void) {
    // 0x4014a0
    int32_t lpBuffer; // bp-520, 0x4014a0
    FormatMessageW(0x1200, NULL, GetLastError(), 1024, (int16_t *)&lpBuffer, 256, NULL);
    int32_t v1 = &lpBuffer; // 0x4014e0
    uint16_t v2 = *(int16_t *)v1; // 0x4014e6
    int32_t v3 = v1 + 2; // 0x4014ec
    int32_t v4 = v1; // 0x4014ec
    while (v2 < 32 != v2 != 9) {
        int32_t v5 = v3;
        v2 = *(int16_t *)v5;
        v3 = v5 + 2;
        v4 = v5;
    }
    *(int16_t *)v4 = 0;
    int32_t v6 = v4 - 2; // 0x4014fd
    while (v6 >= v1) {
        uint16_t v7 = *(int16_t *)v6; // 0x40150a
        if (v7 != 46 && v7 >= 33) {
            // break -> 0x401517
            break;
        }
        *(int16_t *)v6 = 0;
        v6 -= 2;
    }
    // 0x401517
    function_401590("\n");
    return _40___security_check_cookie_40_4();
}

// Address range: 0x401540 - 0x401546
int32_t function_401540(void) {
    // 0x401540
    return &g3;
}

// Address range: 0x401550 - 0x401580
int32_t function_401550(char * a1, int32_t * a2) {
    // 0x401550
    __acrt_iob_func(0);
    int32_t v1 = function_401540(); // 0x40156a
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40156f
    int32_t v3 = *(int32_t *)v1; // 0x401572
    int32_t result = __stdio_common_vfscanf(v3, (struct _IO_FILE *)v2, (char *)&g8, (int32_t)&g8, (int32_t)&g8); // 0x401574
    return result;
}

// Address range: 0x401580 - 0x401586
int32_t function_401580(void) {
    // 0x401580
    return &g4;
}

// Address range: 0x401590 - 0x4015c0
int32_t function_401590(char * a1) {
    // 0x401590
    __acrt_iob_func(1);
    int32_t v1 = function_401580(); // 0x4015aa
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x4015af
    int32_t v3 = *(int32_t *)v1; // 0x4015b2
    int32_t result = __stdio_common_vfprintf(v3, (struct _IO_FILE *)v2, (char *)&g8, (int32_t)&g8, (int32_t)&g8); // 0x4015b4
    return result;
}

// --------------- Statically Linked Functions ----------------

// int32_t _40___security_check_cookie_40_4(void);

// --------------- Dynamically Linked Functions ---------------

// _ACRTIMP_ALT FILE * __cdecl __acrt_iob_func(unsigned);
// int __cdecl __stdio_common_vfprintf(_In_ unsigned __int64 Options, _Inout_ FILE * Stream, _In_z_ char const * Format, _In_opt_ _locale_t Locale, va_list ArgList);
// int __cdecl __stdio_common_vfscanf(_In_ unsigned __int64 Options, _Inout_ FILE * Stream, _In_z_ char const * Format, _In_opt_ _locale_t Locale, va_list Arglist);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// DWORD FormatMessageW(_In_ DWORD dwFlags, _In_opt_ LPCVOID lpSource, _In_ DWORD dwMessageId, _In_ DWORD dwLanguageId, _Out_ LPWSTR lpBuffer, _In_ DWORD nSize, _In_opt_ va_list * Arguments);
// DWORD GetLastError(VOID);
// DWORD GetPriorityClass(_In_ HANDLE hProcess);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// HANDLE OpenThread(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwThreadId);
// BOOL Process32FirstW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// BOOL Process32NextW(HANDLE hSnapshot, LPPROCESSENTRY32W lppe);
// DWORD ResumeThread(_In_ HANDLE hThread);
// DWORD SuspendThread(_In_ HANDLE hThread);
// BOOL Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
// BOOL Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (14.0)
// Detected language: C++
// Detected functions: 9
