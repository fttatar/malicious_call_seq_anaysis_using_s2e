//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

// ------------------------- Classes --------------------------

// .?AVbad_alloc@std@@ (base classes: .?AVexception@std@@)
// .?AVbad_array_new_length@std@@ (base classes: .?AVexception@std@@, .?AVbad_alloc@std@@)
// .?AVexception@std@@
// .?AVtype_info@@

// ------------------- Function Prototypes --------------------

int32_t function_401000(int32_t * a1);
int32_t function_401250(uint32_t a1, uint32_t a2);
int32_t function_401350(uint32_t a1, uint32_t a2);
int32_t function_4013b0(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4014e0(int32_t a1);
int32_t function_4015c7(void);
int32_t function_401680(uint32_t a1);
int32_t function_401770(void);
int32_t function_401780(char * a1);
int32_t function_4017f4(int32_t a1);
int32_t function_401c5d(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x6f727245; // 0x403220
int32_t g2 = 0x6f727245; // 0x403318
int32_t g3 = 0; // 0x4053f0
int32_t g4;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401080
int32_t function_401000(int32_t * a1) {
    int32_t * v1 = _errno(); // 0x40101c
    char * base = (char *)10; // bp-24, 0x401022
    *v1 = 0;
    int32_t wendptr; // bp-12, 0x401000
    int32_t wstr; // 0x401000
    wcstol((int16_t *)wstr, (int16_t **)&wendptr, (int32_t)base);
    int32_t v2; // bp-20, 0x401000
    int32_t v3 = &v2; // 0x40103d
    if (wstr == wendptr) {
        // 0x40103f
        base = "invalid stoi argument";
        _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z("invalid stoi argument");
        v3 = (int32_t)&base;
    }
    // 0x40104a
    if (*_errno() != 34) {
        // 0x401055
        return _40___security_check_cookie_40_4();
    }
    // 0x401067
    *(int32_t *)(v3 - 4) = (int32_t)"stoi argument out of range";
    _3f__Xout_of_range_40_std_40__40_YAXPBD_40_Z((char *)&g4);
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    __asm_int3();
    return __asm_int3();
}

// Address range: 0x401080 - 0x40120d
int main(int argc, char ** argv) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x401090
    __writefsdword(0, (int32_t)&v1);
    if (argc != 2) {
        // 0x4010ae
        function_401780("Wrong usage! give PID!\n");
        getchar();
        exit(-1);
        // UNREACHABLE
    }
    int32_t v2 = *(int32_t *)((int32_t)argv + 4); // 0x4010da
    int32_t v3 = 0; // bp-40, 0x4010df
    int32_t v4 = 0; // 0x4010e6
    if (*(int16_t *)v2 != 0) {
        int32_t v5 = v2 + 2;
        int32_t v6 = v5 + 2; // 0x4010f4
        while (*(int16_t *)v5 != 0) {
            // 0x4010f1
            v5 = v6;
            v6 = v5 + 2;
        }
        // 0x4010fc
        v4 = (-2 - v2 + v6) / 2;
    }
    int32_t v7 = v2; // bp-64, 0x401101
    function_401250(v2, v4);
    int32_t v8 = function_401000(&v3); // 0x401115
    int32_t v9 = &v7; // 0x40111d
    *(int32_t *)(v9 - 4) = v8;
    *(int32_t *)(v9 - 8) = 0;
    *(int32_t *)(v9 - 12) = 0x1fffff;
    int32_t * v10 = OpenProcess((int32_t)&g4, (bool)&g4, (int32_t)&g4); // 0x401139
    int32_t * v11 = (int32_t *)(v9 - 16);
    if (v10 == NULL) {
        // 0x401145
        *v11 = (int32_t)&g1;
        function_401780((char *)&g4);
    }
    // 0x401152
    *v11 = (int32_t)"LoadLibraryA";
    *(int32_t *)(v9 - 20) = (int32_t)L"kernel32.dll";
    *(int32_t *)(v9 - 24) = (int32_t)GetModuleHandleW((int16_t *)&g4);
    int32_t (*func)() = GetProcAddress(&g4, (char *)&g4); // 0x401163
    int32_t * v12 = (int32_t *)(v9 - 28);
    if (func == NULL) {
        // 0x40116f
        *v12 = (int32_t)"Error: the LoadLibraryA function was not found inside kernel32.dll library.\n";
        function_401780((char *)&g4);
    }
    int32_t v13 = (int32_t)v10; // 0x401139
    *v12 = 4;
    *(int32_t *)(v9 - 32) = 0x3000;
    *(int32_t *)(v9 - 36) = 16;
    *(int32_t *)(v9 - 40) = 0;
    *(int32_t *)(v9 - 44) = v13;
    int32_t * v14 = VirtualAllocEx(&g4, &g4, (int32_t)&g4, (int32_t)&g4, (int32_t)&g4); // 0x401188
    int32_t * v15 = (int32_t *)(v9 - 48);
    if (v14 == NULL) {
        // 0x401194
        *v15 = (int32_t)"Error: the memory could not be allocated inside the chosen process.\n";
        function_401780((char *)&g4);
    }
    int32_t v16 = (int32_t)v14; // 0x401188
    *v15 = 0;
    *(int32_t *)(v9 - 52) = 16;
    *(int32_t *)(v9 - 56) = (int32_t)"injected-dll.dll";
    *(int32_t *)(v9 - 60) = v16;
    *(int32_t *)(v9 - 64) = v13;
    bool v17 = WriteProcessMemory(&g4, &g4, &g4, (int32_t)&g4, &g4); // 0x4011ac
    int32_t * v18 = (int32_t *)(v9 - 68);
    if (!v17) {
        // 0x4011b6
        *v18 = (int32_t)&g2;
        function_401780((char *)&g4);
    }
    // 0x4011c3
    *v18 = 0;
    *(int32_t *)(v9 - 72) = 0;
    *(int32_t *)(v9 - 76) = v16;
    *(int32_t *)(v9 - 80) = (int32_t)func;
    *(int32_t *)(v9 - 84) = 0;
    *(int32_t *)(v9 - 88) = 0;
    *(int32_t *)(v9 - 92) = v13;
    int32_t * v19 = CreateRemoteThread(&g4, (struct _SECURITY_ATTRIBUTES *)&g4, (int32_t)&g4, (int32_t (*)(int32_t *))&g4, &g4, (int32_t)&g4, &g4); // 0x4011ce
    int32_t * v20 = (int32_t *)(v9 - 96);
    int32_t v21 = v19 != NULL ? (int32_t)"Success: the remote thread was successfully created.\n" : (int32_t)"Error: the remote thread could not be created.\n";
    *v20 = v21;
    function_401780((char *)&g4);
    *v20 = v13;
    CloseHandle(&g4);
    getchar();
    __writefsdword(0, v1);
    return 0;
}

// Address range: 0x401250 - 0x401345
int32_t function_401250(uint32_t a1, uint32_t a2) {
    // 0x401250
    int32_t v1; // 0x401250
    int32_t v2; // bp-16, 0x401250
    char * v3; // bp-20, 0x401250
    int32_t result; // 0x401250
    if (a1 != 0) {
        int32_t v4 = *(int32_t *)(result + 20); // 0x40125e
        uint32_t v5 = v4 < 8 ? result : v4;
        v1 = v4;
        if (v5 <= a1) {
            // 0x401270
            v1 = v4;
            if (2 * *(int32_t *)(result + 16) + v5 > a1) {
                // 0x401285
                v2 = a2;
                int32_t v6 = (a1 - v5) / 2; // 0x401297
                v3 = (char *)v6;
                int32_t v7; // 0x401250
                int32_t v8; // 0x401250
                int32_t v9; // 0x401250
                return function_4013b0(result, v6, a2, v7, v9, v8);
            }
        }
    }
    int32_t v10 = &v2; // 0x4012b0
    if (a2 >= 0x7fffffff) {
        // 0x4012b2
        v3 = "string too long";
        _3f__Xlength_error_40_std_40__40_YAXPBD_40_Z("string too long");
        v10 = (int32_t)&v3;
    }
    int32_t * v11 = (int32_t *)(result + 20); // 0x4012bd
    uint32_t v12 = *v11; // 0x4012bd
    int32_t * v13; // 0x401250
    int32_t v14; // 0x401250
    int32_t v15; // 0x401250
    if (v12 >= a2) {
        if (a2 == 0) {
            // 0x4012df
            *(int32_t *)(result + 16) = a2;
            if (v12 < 8) {
                // 0x4012f8
                *(int16_t *)result = 0;
                return result;
            }
            // 0x4012e8
            *(int16_t *)v1 = 0;
            return result;
        }
        // 0x4012d1
        v13 = (int32_t *)(result + 16);
        v15 = v12 < 8 ? result : v1;
        v14 = v10;
    } else {
        int32_t * v16 = (int32_t *)(result + 16);
        *(int32_t *)(v10 - 4) = *v16;
        int32_t v17 = v10 - 8; // 0x4012c7
        *(int32_t *)v17 = a2;
        function_4014e0((int32_t)&g4);
        v13 = v16;
        v14 = v17;
        if (a2 == 0) {
            // 0x40133c
            return result;
        }
    }
    int32_t v18 = 2 * a2;
    *(int32_t *)(v14 - 4) = v18;
    *(int32_t *)(v14 - 8) = a1;
    *(int32_t *)(v14 - 12) = v15;
    memcpy(&g4, &g4, (int32_t)&g4);
    *v13 = a2;
    if (*v11 >= 8) {
        // 0x401323
        *(int16_t *)(v15 + v18) = 0;
        return result;
    }
    // 0x401334
    *(int16_t *)(result + v18) = 0;
    // 0x40133c
    return result;
}

// Address range: 0x401350 - 0x4013ae
int32_t function_401350(uint32_t a1, uint32_t a2) {
    int32_t v1 = a2; // 0x40135e
    if (a2 <= 0xffffffff) {
        // 0x401360
        _invalid_parameter_noinfo_noreturn();
        v1 = &g4;
    }
    // 0x401366
    if (2 * v1 < 0x1000) {
        // 0x4013a1
        return function_4017f4(a1);
    }
    if ((a1 & 31) != 0) {
        // 0x401374
        _invalid_parameter_noinfo_noreturn();
    }
    uint32_t v2 = *(int32_t *)(a1 - 4); // 0x40137a
    int32_t v3 = v2; // 0x40137f
    if (v2 >= a1) {
        // 0x401381
        _invalid_parameter_noinfo_noreturn();
        v3 = &g4;
    }
    uint32_t v4 = a1 - v3; // 0x401387
    int32_t v5 = v3; // 0x40138c
    if (v4 < 4) {
        // 0x40138e
        _invalid_parameter_noinfo_noreturn();
        v5 = &g4;
    }
    int32_t v6 = v5; // 0x401397
    if (v4 >= 36) {
        // 0x401399
        _invalid_parameter_noinfo_noreturn();
        v6 = &g4;
    }
    // 0x4013a1
    return function_4017f4(v6);
}

// Address range: 0x4013b0 - 0x4014d7
int32_t function_4013b0(int32_t a1, uint32_t a2, uint32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    uint32_t v1 = *(int32_t *)(a1 + 16); // 0x4013be
    int32_t v2 = v1; // 0x4013c3
    int32_t v3; // bp-16, 0x4013b0
    int32_t v4 = &v3; // 0x4013c3
    if (v1 < a2) {
        char * v5 = "invalid string position"; // bp-20, 0x4013c5
        v2 = _3f__Xout_of_range_40_std_40__40_YAXPBD_40_Z("invalid string position");
        v4 = (int32_t)&v5;
    }
    uint32_t v6 = v2 - a2; // 0x4013d3
    uint32_t v7 = v6 < a3 ? v6 : a3; // 0x4013d7
    int32_t result; // 0x4013b0
    if (result == a1) {
        int32_t v8 = v7 + a2; // 0x4013de
        int32_t * v9 = (int32_t *)(result + 16); // 0x4013e1
        int32_t v10 = v8; // 0x4013e4
        int32_t v11 = v4; // 0x4013e4
        if (*v9 < v8) {
            // 0x4013e6
            v11 = v4 - 4;
            *(int32_t *)v11 = (int32_t)"invalid string position";
            v10 = _3f__Xout_of_range_40_std_40__40_YAXPBD_40_Z((char *)&g4);
        }
        // 0x4013f1
        *v9 = v10;
        *(int32_t *)(v11 - 4) = a2;
        *(int32_t *)(v11 - 8) = a2;
        int32_t v12 = 2 * v10;
        if (*(int32_t *)(result + 20) < 8) {
            // 0x401414
            *(int16_t *)(v12 + result) = 0;
            function_401680((int32_t)&g4);
            return result;
        }
        // 0x4013fa
        *(int16_t *)(v12 + a2) = 0;
        function_401680((int32_t)&g4);
        return result;
    }
    int32_t v13 = v4; // 0x401434
    if (v7 >= 0x7fffffff) {
        // 0x401436
        v13 = v4 - 4;
        *(int32_t *)v13 = (int32_t)"string too long";
        _3f__Xlength_error_40_std_40__40_YAXPBD_40_Z((char *)&g4);
    }
    int32_t * v14 = (int32_t *)(result + 20); // 0x401441
    uint32_t v15 = *v14; // 0x401441
    int32_t v16; // 0x4013b0
    if (v15 >= v7) {
        // 0x40146a
        v16 = v13;
        if (v7 == 0) {
            // 0x40146e
            *(int32_t *)(result + 16) = v7;
            if (v15 < 8) {
                // 0x401487
                *(int16_t *)result = 0;
                return result;
            }
            // 0x401477
            *(int16_t *)a2 = 0;
            return result;
        }
    } else {
        // 0x401446
        *(int32_t *)(v13 - 4) = *(int32_t *)(result + 16);
        int32_t v17 = v13 - 8; // 0x40144b
        *(int32_t *)v17 = v7;
        function_4014e0((int32_t)&g4);
        v16 = v17;
        if (v7 == 0) {
            // 0x4014ce
            return result;
        }
    }
    int32_t v18 = a1; // 0x40145c
    if (*(int32_t *)(a1 + 20) >= 8) {
        // 0x40145e
        v18 = *(int32_t *)a1;
    }
    int32_t v19 = 0; // 0x401499
    if (v7 != 0) {
        // 0x40149b
        v19 = 2 * v7;
        *(int32_t *)(v16 - 4) = v19;
        *(int32_t *)(v16 - 8) = v18 + 2 * a2;
        *(int32_t *)(v16 - 12) = *v14 < 8 ? result : a2;
        memcpy(&g4, &g4, (int32_t)&g4);
    }
    // 0x4014ac
    *(int32_t *)(result + 16) = v7;
    if (*v14 >= 8) {
        // 0x4014b5
        *(int16_t *)(v19 + a2) = 0;
        return result;
    }
    // 0x4014c6
    *(int16_t *)(v19 + result) = 0;
    // 0x4014ce
    return result;
}

// Address range: 0x4014e0 - 0x4015a1
int32_t function_4014e0(int32_t a1) {
    int32_t v1 = __readfsdword(0); // bp-16, 0x4014f0
    __writefsdword(0, (int32_t)&v1);
    uint32_t v2 = a1 | 7; // 0x401515
    int32_t v3 = a1; // 0x40151e
    if (v2 < 0x7ffffffe) {
        // 0x401524
        int32_t v4; // 0x4014e0
        uint32_t v5 = *(int32_t *)(v4 + 20); // 0x401524
        uint32_t v6 = v5 / 2; // 0x401530
        v3 = v2;
        if (v6 > v2 / 3) {
            // 0x401538
            v3 = v5 > 0x7ffffffe - v6 ? 0x7ffffffe : v6 + v5;
        }
    }
    int32_t v7 = v3 + 1; // 0x40154b
    if (v7 == 0) {
        // 0x401559
        return function_4015c7();
    }
    int32_t v8 = v7; // 0x401562
    if (v7 <= 0xffffffff) {
        // 0x401564
        v8 = ?_Xbad_alloc@std@@YAXXZ();
    }
    uint32_t v9 = 2 * v8; // 0x40156a
    if (v9 < 0x1000) {
        // 0x401594
        _3f__3f_2_40_YAPAXI_40_Z(v9);
        return function_4015c7();
    }
    if (v9 > 0xffffffdc) {
        // 0x40157a
        ?_Xbad_alloc@std@@YAXXZ();
    }
    int32_t v10 = _3f__3f_2_40_YAPAXI_40_Z(v9 + 35); // 0x401581
    *(int32_t *)((v10 + 35 & -32) - 4) = v10;
    return function_4015c7();
}

// Address range: 0x4015c7 - 0x401648
int32_t function_4015c7(void) {
    // 0x4015c7
    int32_t v1; // 0x4015c7
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x4015c7
    int32_t v3 = *v2; // 0x4015c7
    int32_t v4; // 0x4015c7
    int32_t v5; // 0x4015c7
    if (v3 != 0) {
        // 0x4015de
        memcpy((int32_t *)v5, (int32_t *)v4, 2 * v3);
    }
    int32_t * v6 = (int32_t *)(v4 + 20); // 0x4015eb
    uint32_t v7 = *v6; // 0x4015eb
    if (v7 >= 8) {
        // 0x4015f3
        function_401350(v4, v7 + 1);
    }
    // 0x4015fc
    *v6 = 7;
    int32_t * v8 = (int32_t *)(v4 + 16); // 0x401607
    *v8 = 0;
    *(int16_t *)v4 = 0;
    int32_t result = *v2; // 0x40161b
    *v8 = result;
    uint32_t v9; // 0x4015c7
    *(int16_t *)(2 * result + (v9 < 8 ? v4 : v5)) = 0;
    __writefsdword(0, *(int32_t *)(v1 - 12));
    return result;
}

// Address range: 0x401680 - 0x401709
int32_t function_401680(uint32_t a1) {
    // 0x401680
    int32_t result; // 0x401680
    int32_t * v1 = (int32_t *)(result + 16); // 0x40168a
    uint32_t v2 = *v1; // 0x40168a
    if (v2 <= a1) {
        // 0x401691
        *v1 = 0;
        if (*(int32_t *)(result + 20) < 8) {
            // 0x4016ad
            *(int16_t *)result = 0;
            return result;
        }
        // 0x40169e
        *(int16_t *)a1 = 0;
        return result;
    }
    if (a1 == 0) {
        // 0x401701
        return result;
    }
    int32_t * v3 = (int32_t *)(result + 20); // 0x4016be
    uint32_t v4 = *v3;
    int32_t v5 = v2 - a1; // 0x4016ca
    int32_t v6 = 0; // 0x4016cc
    int32_t v7 = v4; // 0x4016cc
    if (v5 != 0) {
        int32_t v8 = v4 < 8 ? result : a1;
        v6 = 2 * v5;
        memmove((int32_t *)v8, (int32_t *)(v8 + 2 * a1), v6);
        v7 = *v3;
    }
    // 0x4016e0
    *v1 = v5;
    if (v7 >= 8) {
        // 0x4016e9
        *(int16_t *)(v6 + a1) = 0;
        return result;
    }
    // 0x4016f9
    *(int16_t *)(v6 + result) = 0;
    // 0x401701
    return result;
}

// Address range: 0x401770 - 0x401776
int32_t function_401770(void) {
    // 0x401770
    return &g3;
}

// Address range: 0x401780 - 0x4017b0
int32_t function_401780(char * a1) {
    // 0x401780
    __acrt_iob_func(1);
    int32_t v1 = function_401770(); // 0x40179a
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x40179f
    int32_t v3 = *(int32_t *)v1; // 0x4017a2
    int32_t result = __stdio_common_vfprintf(v3, (struct _IO_FILE *)v2, (char *)&g4, (int32_t)&g4, (int32_t)&g4); // 0x4017a4
    return result;
}

// Address range: 0x4017f4 - 0x4017f9
int32_t function_4017f4(int32_t a1) {
    // 0x4017f4
    free(&g4);
    return &g4;
}

// Address range: 0x401c5d - 0x401c6a
// From class:    .?AVbad_alloc@std@@
// Type:          virtual member function
int32_t function_401c5d(void) {
    // 0x401c5d
    int32_t v1; // 0x401c5d
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x401c5d
    return v2 != 0 ? v2 : (int32_t)"Unknown exception";
}

// --------------- Statically Linked Functions ----------------

// int32_t _3f__3f_2_40_YAPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G__non_rtti_object_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _3f__3f__G_Ref_count_base_40_std_40__40_UAEPAXI_40_Z(int32_t a1);
// int32_t _40___security_check_cookie_40_4(void);

// --------------- Dynamically Linked Functions ---------------

// int32_t ?_Xbad_alloc@std@@YAXXZ(void);
// int32_t _3f__Xinvalid_argument_40_std_40__40_YAXPBD_40_Z(char * a1);
// int32_t _3f__Xlength_error_40_std_40__40_YAXPBD_40_Z(char * a1);
// int32_t _3f__Xout_of_range_40_std_40__40_YAXPBD_40_Z(char * a1);
// _ACRTIMP_ALT FILE * __cdecl __acrt_iob_func(unsigned);
// int __cdecl __stdio_common_vfprintf(_In_ unsigned __int64 Options, _Inout_ FILE * Stream, _In_z_ char const * Format, _In_opt_ _locale_t Locale, va_list ArgList);
// int * __cdecl _errno(void);
// void __cdecl _invalid_parameter_noinfo_noreturn(void);
// BOOL CloseHandle(_In_ HANDLE hObject);
// HANDLE CreateRemoteThread(_In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// void exit(int status);
// void free(void * ptr);
// int getchar(void);
// HMODULE GetModuleHandleW(_In_opt_ LPCWSTR lpModuleName);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memmove(void * dest, const void * src, size_t n);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// LPVOID VirtualAllocEx(_In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect);
// long int wcstol(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
// BOOL WriteProcessMemory(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (14.0)
// Detected language: C++
// Detected functions: 12
