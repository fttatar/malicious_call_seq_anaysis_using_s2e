// malware-hook.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include <Windows.h>
#include <iostream>
#include <fstream> 
#include <string>
#include <strsafe.h>
#include <tlhelp32.h> /* Process32NextW gibi.. */
#include <easyhook.h>
#include <wincrypt.h>
#include <winnt.h>
#include <math.h>
//#include <excpt.h>

#if _WIN64
#pragma comment(lib, "EasyHook64.lib")
#else
#pragma comment(lib, "EasyHook32.lib")
#endif

#pragma comment(lib, "libcommon.lib")

#define USER_APP
extern "C" {
#include <s2e/s2e.h>
}

#define S2E_MSG_LEN 512

static INT s2eVersion = 0;

using namespace std;
static string trigger;

static void Message(LPCSTR fmt, ...) {
	CHAR message[S2E_MSG_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(message, S2E_MSG_LEN, fmt, args);
	va_end(args);

	if (s2eVersion) {
		S2EMessageFmt("[PID:0x%x|HOOK] %s", GetCurrentProcessId(),
			message);
	}
	else {
		printf("[PID:0x%x|HOOK] %s", GetCurrentProcessId(), message);
	}
}

static BOOL AdjustTokenPrivileges_Model(_In_ HANDLE TokenHandle, _In_ BOOL DisableAllPrivileges, _In_opt_ PTOKEN_PRIVILEGES NewState, _In_ DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, _Out_opt_ PDWORD ReturnLength)
{
	Message("AdjustTokenPrivileges_Model\n");
	return TRUE;
}

static BOOL AllocateAndInitializeSid_Model(_In_ PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, _In_ BYTE nSubAuthorityCount, _In_ DWORD nSubAuthority0, _In_ DWORD nSubAuthority1, _In_ DWORD nSubAuthority2, _In_ DWORD nSubAuthority3, _In_ DWORD nSubAuthority4, _In_ DWORD nSubAuthority5, _In_ DWORD nSubAuthority6, _In_ DWORD nSubAuthority7, PSID* pSid)
{
	Message("AllocateAndInitializeSid_Model\n");
	return TRUE;
}

static int CompareStringA_Model(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2)
{
	Message("CompareStringA_Model\n");
	return 1;
}

static int CompareStringW_Model(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZWCH lpString1, _In_ int cchCount1, PCNZWCH lpString2, _In_ int cchCount2)
{
	Message("CompareStringW_Model\n");
	return 1;
}

static BOOL ControlService_Model(_In_ SC_HANDLE hService, _In_ DWORD dwControl, _Out_ LPSERVICE_STATUS lpServiceStatus)
{
	Message("ControlService_Model\n");
	return TRUE;
}

static HANDLE CreateEventA_Model(_In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCSTR lpName)
{
	Message("CreateEventA_Model\n");
	return NULL;
}

static BOOL WINAPI CloseHandle_Model(HANDLE hObject) {
	Message("CloseHandle_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "CloseHandle_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static HANDLE WINAPI CreateToolhelp32Snapshot_Model(DWORD dwFlags, DWORD th32ProcessID) {
	Message("CreateToolhelp32Snapshot_Model\n");
	HANDLE retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "CreateToolhelp32Snapshot_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static HANDLE CreateRemoteThread_Model(_In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId) {
	Message("CreateRemoteThread_Model\n");
	HANDLE retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "CreateRemoteThread_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static void* calloc_Model(size_t nmemb, size_t size)
{
	Message("calloc_Model\n");
	return NULL;
}

static BOOL CloseServiceHandle_Model(_In_ SC_HANDLE hSCObject)
{
	Message("CloseServiceHandle_Model\n");
	return TRUE;
}

static BOOL CopyFileA_Model(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists)
{
	Message("CopyFileA_Model\n");
	return TRUE;
}

static BOOL CreateDirectoryA_Model(_In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	Message("CreateDirectoryA_Model\n");
	return TRUE;
}

static BOOL CreateDirectoryW_Model(_In_ LPCWSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	Message("CreateDirectoryW_Model\n");
	return TRUE;
}

static HANDLE CreateFileA_Model(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)
{
	Message("CreateFileA_Model\n");
	return NULL;
}

static BOOL CreateProcessA_Model(_In_opt_ LPCSTR lpApplicationName, _Inout_opt_ LPSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCSTR lpCurrentDirectory, _In_ LPSTARTUPINFOA lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation)
{
	Message("CreateProcessA_Model\n");
	return TRUE;
}

static SC_HANDLE CreateServiceA_Model(_In_ SC_HANDLE hSCManager, _In_ LPCSTR lpServiceName, _In_opt_ LPCSTR lpDisplayName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwServiceType, _In_ DWORD dwStartType, _In_ DWORD dwErrorControl, _In_opt_ LPCSTR lpBinaryPathName, _In_opt_ LPCSTR lpLoadOrderGroup, _Out_opt_ LPDWORD lpdwTagId, _In_opt_ LPCSTR lpDependencies, _In_opt_ LPCSTR lpServiceStartName, _In_opt_ LPCSTR lpPassword)
{
	Message("CreateServiceA_Model\n");
	return NULL;
}

static BOOL CryptReleaseContext_Model(_In_ HCRYPTPROV hProv, _In_ DWORD dwFlags)
{
	Message("CryptReleaseContext_Model\n");
	return TRUE;
}

static BOOL DeleteFileA_Model(_In_ LPCSTR lpFileName)
{
	Message("DeleteFileA_Model\n");
	return TRUE;
}

static BOOL DeviceIoControl_Model(_In_ HANDLE hDevice, _In_ DWORD dwIoControlCode, LPVOID lpInBuffer, _In_ DWORD nInBufferSize, LPVOID lpOutBuffer, _In_ DWORD nOutBufferSize, _Out_opt_ LPDWORD lpBytesReturned, _Inout_opt_ LPOVERLAPPED lpOverlapped)
{
	Message("DeviceIoControl_Model\n");
	return TRUE;
}

static VOID DeleteCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("DeleteCriticalSection_Model\n");
	return;
}

static BOOL EqualSid_Model(_In_ PSID pSid1, _In_ PSID pSid2)
{
	Message("EqualSid_Model\n");
	return TRUE;
}

static VOID ExitProcess_Model(_In_ UINT uExitCode)
{
	Message("ExitProcess_Model\n");
	return;
}
//
//static PVOID ExAllocatePool_Model(_In_ POOL_TYPE PoolType, _In_ SIZE_T NumberOfBytes)
//{
//	Message("ExAllocatePool_Model\n");
//	return NULL;
//}
//
static VOID ExFreePoolWithTag_Model(PVOID P, _In_ ULONG Tag)
{
	Message("ExFreePoolWithTag_Model\n");
	return;
}

static VOID EnterCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("EnterCriticalSection_Model\n");
	return;
}

static void exit_Model(int status)
{
	Message("exit_Model\n");
	return;
}

static DWORD WINAPI FormatMessageW_Model(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, _Out_ LPWSTR lpBuffer, DWORD nSize, va_list * Arguments) {
	Message("FormatMessageW_Model\n");
	DWORD retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "FormatMessageW_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static BOOL FindClose_Model(_Inout_ HANDLE hFindFile)
{
	Message("FindClose_Model\n");
	return TRUE;
}

static HANDLE FindFirstFileA_Model(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData)
{
	Message("FindFirstFileA_Model\n");
	return NULL;
}

static BOOL FindNextFileA_Model(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData)
{
	Message("FindNextFileA_Model\n");
	return TRUE;
}

static BOOL FlushFileBuffers_Model(_In_ HANDLE hFile)
{
	Message("FlushFileBuffers_Model\n");
	return TRUE;
}

static BOOL FreeEnvironmentStringsA_Model(_In_ LPCH penv)
{
	Message("FreeEnvironmentStringsA_Model\n");
	return TRUE;
}

static BOOL FreeEnvironmentStringsW_Model(_In_ LPWCH penv)
{
	Message("FreeEnvironmentStringsW_Model\n");
	return TRUE;
}

static PVOID FreeSid_Model(_In_ PSID pSid)
{
	Message("FreeSid_Model\n");
	return NULL;
}

static int fclose_Model(FILE* stream)
{
	Message("fclose_Model\n");
	return 1;
}

static HRSRC FindResourceA_Model(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType)
{
	Message("FindResourceA_Model\n");
	return NULL;
}

static FILE* fopen_Model(const char* filename, const char* modes)
{
	Message("fopen_Model\n");
	return NULL;
}

static size_t fread_Model(void* ptr, size_t size, size_t n, FILE* stream)
{
	Message("fread_Model\n");
	return 1;
}

static void free_Model(void* ptr)
{
	Message("free_Model\n");
	return;
}

static BOOL FreeLibrary_Model(_In_ HMODULE hLibModule)
{
	Message("FreeLibrary_Model\n");
	return TRUE;
}

static size_t fwrite_Model(const void* ptr, size_t size, size_t n, FILE* s)
{
	Message("fwrite_Model\n");
	return 1;
}

static DWORD WINAPI GetLastError_Model(VOID) {
	Message("GetLastError_Model\n");
	DWORD retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetLastError_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static HMODULE GetModuleHandleW_Model(_In_opt_ LPCWSTR lpModuleName) {
	Message("GetModuleHandleW_Model\n");
	HMODULE retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetModuleHandleW_Model");
	}
	else
	{
		/* Concrete output */
	}
	
	//Message("[GetModuleHandleW_Model|evidence] lpModuleName: {[%s]}", lpModuleName);

	return retVal;
}
static DWORD WINAPI GetPriorityClass_Model(HANDLE hProcess) {
	Message("GetPriorityClass_Model\n");
	DWORD retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetPriorityClass_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static FARPROC GetProcAddress_Model(_In_ HMODULE hModule, _In_ LPCSTR lpProcName) {
	Message("GetProcAddress_Model\n");
	FARPROC retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetProcAddress_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static void WINAPI GetLocalTime_Model(LPSYSTEMTIME lpSystemTime) {
	Message("GetLocalTime_Model\n");

	// Call the original GetLocalTime to get a concrete value
	GetLocalTime(lpSystemTime);

	// Make the value concolic
	S2EMakeSymbolic(lpSystemTime, sizeof(*lpSystemTime), "SystemTime");
}

static UINT GetACP_Model(void)
{
	Message("GetACP_Model\n");
	return 1u;
}

static LPSTR GetCommandLineA_Model(VOID)
{
	Message("GetCommandLineA_Model\n");
	return NULL;
}

static BOOL GetCPInfo_Model(_In_ UINT CodePage, _Out_ LPCPINFO lpCPInfo)
{
	Message("GetCPInfo_Model\n");
	return TRUE;
}

static HANDLE GetCurrentProcess_Model(VOID)
{
	Message("GetCurrentProcess_Model\n");
	return NULL;
}

static DWORD GetCurrentThreadId_Model(VOID)
{
	Message("GetCurrentThreadId_Model\n");
	return 1;
}

static UINT GetDriveTypeA_Model(_In_opt_ LPCSTR lpRootPathName)
{
	Message("GetDriveTypeA_Model\n");
	return 1u;
}

static LPCH GetEnvironmentStrings_Model(VOID)
{
	Message("GetEnvironmentStrings_Model\n");
	return NULL;
}

static LPWCH GetEnvironmentStringsW_Model(void)
{
	Message("GetEnvironmentStringsW_Model\n");
	return NULL;
}

static DWORD GetFileType_Model(_In_ HANDLE hFile)
{
	Message("GetFileType_Model\n");
	return 1;
}

static DWORD GetLogicalDriveStringsA_Model(_In_ DWORD nBufferLength, LPSTR lpBuffer)
{
	Message("GetLogicalDriveStringsA_Model\n");
	return 1;
}

static UINT GetOEMCP_Model(void)
{
	Message("GetOEMCP_Model\n");
	return 1u;
}

static DWORD GetShortPathNameA_Model(_In_ LPCSTR lpszLongPath, LPSTR lpszShortPath, _In_ DWORD cchBuffer)
{
	Message("GetShortPathNameA_Model\n");
	return 1;
}

static VOID GetStartupInfoA_Model(_Out_ LPSTARTUPINFOA lpStartupInfo)
{
	Message("GetStartupInfoA_Model\n");
	return;
}

static HANDLE GetStdHandle_Model(_In_ DWORD nStdHandle)
{
	Message("GetStdHandle_Model\n");
	return NULL;
}

static BOOL GetStringTypeA_Model(_In_ LCID Locale, _In_ DWORD dwInfoType, LPCSTR lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType)
{
	Message("GetStringTypeA_Model\n");
	return TRUE;
}

static BOOL GetStringTypeW_Model(_In_ DWORD dwInfoType, LPCWCH lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType)
{
	Message("GetStringTypeW_Model\n");
	return TRUE;
}

static VOID GetSystemInfo_Model(_Out_ LPSYSTEM_INFO lpSystemInfo)
{
	Message("GetSystemInfo_Model\n");
	return;
}

static VOID GetSystemTime_Model(_Out_ LPSYSTEMTIME lpSystemTime)
{
	Message("GetSystemTime_Model\n");
	return;
}

static DWORD GetTickCount_Model(VOID)
{
	Message("GetTickCount_Model\n");
	return 1;
}

static DWORD GetTimeZoneInformation_Model(_Out_ LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
{
	Message("GetTimeZoneInformation_Model\n");
	return 1;
}

static BOOL GetTokenInformation_Model(_In_ HANDLE TokenHandle, _In_ TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, _In_ DWORD TokenInformationLength, _Out_ PDWORD ReturnLength)
{
	Message("GetTokenInformation_Model\n");
	return TRUE;
}

static NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion_Model(VOID)
{
	Message("DWORD GetVersion_Model\n");
	return 0;
}

static NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExA_Model(_Inout_ LPOSVERSIONINFOA lpVersionInformation)
{
	Message("BOOL GetVersionExA_Model\n");
	return 0;
}

static UINT GetWindowsDirectoryA_Model(LPSTR lpBuffer, _In_ UINT uSize)
{
	Message("GetWindowsDirectoryA_Model\n");
	return 1u;
}

static BOOL GetComputerNameW_Model(LPWSTR lpBuffer, _Inout_ LPDWORD nSize)
{
	Message("GetComputerNameW_Model\n");
	return TRUE;
}

static DWORD GetCurrentDirectoryA_Model(_In_ DWORD nBufferLength, LPSTR lpBuffer)
{
	Message("GetCurrentDirectoryA_Model\n");
	return 1;
}

static BOOL GetExitCodeProcess_Model(_In_ HANDLE hProcess, _Out_ LPDWORD lpExitCode)
{
	Message("GetExitCodeProcess_Model\n");
	return TRUE;
}

static DWORD GetFileAttributesA_Model(_In_ LPCSTR lpFileName)
{
	Message("GetFileAttributesA_Model\n");
	return 1;
}

static DWORD GetFileAttributesW_Model(_In_ LPCWSTR lpFileName)
{
	Message("GetFileAttributesW_Model\n");
	return 1;
}

static DWORD GetFileSize_Model(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh)
{
	Message("GetFileSize_Model\n");
	return 1;
}

static BOOL GetFileSizeEx_Model(_In_ HANDLE hFile, _Out_ PLARGE_INTEGER lpFileSize)
{
	Message("GetFileSizeEx_Model\n");
	return TRUE;
}

static DWORD GetFullPathNameA_Model(_In_ LPCSTR lpFileName, _In_ DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart)
{
	Message("GetFullPathNameA_Model\n");
	return 1;
}

static DWORD GetModuleFileNameA_Model(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize)
{
	Message("GetModuleFileNameA_Model\n");
	return 1;
}

static HMODULE GetModuleHandleA_Model(_In_opt_ LPCSTR lpModuleName)
{
	Message("GetModuleHandleA_Model\n");
	return NULL;
}

static HANDLE GetProcessHeap_Model(VOID)
{
	Message("GetProcessHeap_Model\n");
	return NULL;
}


static DWORD GetTempPathW_Model(_In_ DWORD nBufferLength, LPWSTR lpBuffer)
{
	Message("GetTempPathW_Model\n");
	return 1;
}

static UINT GetWindowsDirectoryW_Model(LPWSTR lpBuffer, _In_ UINT uSize)
{
	Message("GetWindowsDirectoryW_Model\n");
	return 1u;
}

static HGLOBAL GlobalAlloc_Model(_In_ UINT uFlags, _In_ SIZE_T dwBytes)
{
	Message("GlobalAlloc_Model\n");
	return NULL;
}

static HGLOBAL GlobalFree_Model(HGLOBAL hMem)
{
	Message("GlobalFree_Model\n");
	return NULL;
}


static HANDLE HeapCreate_Model(_In_ DWORD flOptions, _In_ SIZE_T dwInitialSize, _In_ SIZE_T dwMaximumSize)
{
	Message("HeapCreate_Model\n");
	return NULL;
}

static BOOL HeapDestroy_Model(_In_ HANDLE hHeap)
{
	Message("HeapDestroy_Model\n");
	return TRUE;
}

static LPVOID HeapReAlloc_Model(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem, _In_ SIZE_T dwBytes)
{
	Message("HeapReAlloc_Model\n");
	return NULL;
}

static SIZE_T HeapSize_Model(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ LPCVOID lpMem)
{
	Message("HeapSize_Model\n");
	return 1;
}

static LPVOID HeapAlloc_Model(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes)
{
	Message("HeapAlloc_Model\n");
	return NULL;
}

static BOOL HeapFree_Model(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem)
{
	Message("HeapFree_Model\n");
	return TRUE;
}

static VOID InitializeCriticalSection_Model(_Out_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("InitializeCriticalSection_Model\n");
	return;
}

static BOOL IsBadCodePtr_Model(_In_opt_ FARPROC lpfn)
{
	Message("IsBadCodePtr_Model\n");
	return TRUE;
}


static BOOL IsBadWritePtr_Model(_In_opt_ LPVOID lp, _In_ UINT_PTR ucb)
{
	Message("IsBadWritePtr_Model\n");
	return TRUE;
}


static BOOL IsBadReadPtr_Model(_In_opt_ const VOID* lp, _In_ UINT_PTR ucb)
{
	Message("IsBadReadPtr_Model\n");
	return TRUE;
}

static int LCMapStringA_Model(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCSTR lpSrcStr, _In_ int cchSrc, LPSTR lpDestStr, _In_ int cchDest)
{
	Message("LCMapStringA_Model\n");
	return 1;
}

static int LCMapStringW_Model(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCWSTR lpSrcStr, _In_ int cchSrc, LPWSTR lpDestStr, _In_ int cchDest)
{
	Message("LCMapStringW_Model\n");
	return 1;
}

static VOID LeaveCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("LeaveCriticalSection_Model\n");
	return;
}

static HMODULE LoadLibraryA_Model(_In_ LPCSTR lpLibFileName)
{
	Message("LoadLibraryA_Model\n");
	return NULL;
}

static BOOL LookupPrivilegeValueA_Model(_In_opt_ LPCSTR lpSystemName, _In_ LPCSTR lpName, _Out_ PLUID lpLuid)
{
	Message("LookupPrivilegeValueA_Model\n");
	return TRUE;
}

static HGLOBAL LoadResource_Model(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo)
{
	Message("LoadResource_Model\n");
	return NULL;
}

static BOOL LocalFileTimeToFileTime_Model(_In_ const FILETIME* lpLocalFileTime, _Out_ LPFILETIME lpFileTime)
{
	Message("LocalFileTimeToFileTime_Model\n");
	return TRUE;
}

static LPVOID LockResource_Model(_In_ HGLOBAL hResData)
{
	Message("LockResource_Model\n");
	return NULL;
}

static BOOL MoveFileA_Model(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName)
{
	Message("MoveFileA_Model\n");
	return TRUE;
}

static BOOL MoveFileExA_Model(_In_ LPCSTR lpExistingFileName, _In_opt_ LPCSTR lpNewFileName, _In_ DWORD dwFlags)
{
	Message("MoveFileExA_Model\n");
	return TRUE;
}

static void* malloc_Model(size_t size)
{
	Message("malloc_Model\n");
	return NULL;
}

static int memcmp_Model(const void* s1, const void* s2, size_t n)
{
	Message("memcmp_Model\n");
	return 1;
}

static void* memcpy_Model(void* dest, const void* src, size_t n)
{
	Message("memcpy_Model\n");
	return NULL;
}

static void* memset_Model(void* s, int c, size_t n)
{
	Message("memset_Model\n");
	return NULL;
}

static int MultiByteToWideChar_Model(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar)
{
	Message("MultiByteToWideChar_Model\n");
	return 1;
}

static HANDLE WINAPI OpenProcess_Model(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId) {
	Message("OpenProcess_Model\n");
	HANDLE retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		S2EMakeSymbolic(&retVal, sizeof(retVal), "OpenProcess_Model");
	}
	else
	{
		/* Concrete output */
	}

	Message("[OpenProcess_Model|evidence] dwProcessId: {[0X%x]}", dwProcessId);

	return retVal;
}

static HANDLE WINAPI OpenThread_Model(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId) {
	Message("OpenThread_Model\n");
	HANDLE retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "OpenThread_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static BOOL OpenProcessToken_Model(_In_ HANDLE ProcessHandle, _In_ DWORD DesiredAccess, PHANDLE TokenHandle)
{
	Message("OpenProcessToken_Model\n");
	return TRUE;
}

static VOID OutputDebugStringA_Model(_In_opt_ LPCSTR lpOutputString)
{
	Message("OutputDebugStringA_Model\n");
	return;
}

static HANDLE OpenMutexA_Model(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCSTR lpName)
{
	Message("OpenMutexA_Model\n");
	return NULL;
}

static SC_HANDLE OpenSCManagerA_Model(_In_opt_ LPCSTR lpMachineName, _In_opt_ LPCSTR lpDatabaseName, _In_ DWORD dwDesiredAccess)
{
	Message("OpenSCManagerA_Model\n");
	return NULL;
}

static SC_HANDLE OpenServiceA_Model(_In_ SC_HANDLE hSCManager, _In_ LPCSTR lpServiceName, _In_ DWORD dwDesiredAccess)
{
	Message("OpenServiceA_Model\n");
	return NULL;
}

static BOOL WINAPI Process32FirstW_Model(HANDLE hSnapshot, LPPROCESSENTRY32W lppe) {
	Message("Process32FirstW_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "Process32FirstW_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static BOOL WINAPI Process32NextW_Model(HANDLE hSnapshot, LPPROCESSENTRY32W lppe) {
	Message("Process32NextW_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "Process32NextW_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static int rand_Model(void)
{
	Message("rand_Model\n");
	return 1;
}

static void* realloc_Model(void* ptr, size_t size)
{
	Message("realloc_Model\n");
	return NULL;
}

static LSTATUS RegCreateKeyW_Model(_In_ HKEY hKey, _In_opt_ LPCWSTR lpSubKey, _Out_ PHKEY phkResult)
{
	Message("RegCreateKeyW_Model\n");
	return 4;
}

static LSTATUS RegSetValueExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE* lpData, _In_ DWORD cbData)
{
	Message("RegSetValueExA_Model\n");
	return 4;
}
static BOOL QueryPerformanceCounter_Model(_Out_ LARGE_INTEGER* lpPerformanceCount)
{
	Message("QueryPerformanceCounter_Model\n");
	return TRUE;
}

static BOOL QueryPerformanceFrequency_Model(_Out_ LARGE_INTEGER* lpFrequency)
{
	Message("QueryPerformanceFrequency_Model\n");
	return TRUE;
}

static BOOL QueryServiceStatus_Model(_In_ SC_HANDLE hService, _Out_ LPSERVICE_STATUS lpServiceStatus)
{
	Message("QueryServiceStatus_Model\n");
	return TRUE;
}

static DWORD WINAPI ResumeThread_Model(HANDLE hThread) {
	Message("ResumeThread_Model\n");
	DWORD retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "ResumeThread_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static BOOL ReadFile_Model(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped)
{
	Message("ReadFile_Model\n");
	return TRUE;
}

static LSTATUS RegCloseKey_Model(_In_ HKEY hKey)
{
	Message("RegCloseKey_Model\n");
	return 4;
}

static LSTATUS RegCreateKeyExA_Model(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition)
{
	Message("RegCreateKeyExA_Model\n");
	return 4;
}

static LSTATUS RegDeleteValueA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName)
{
	Message("RegDeleteValueA_Model\n");
	return 4;
}

static LSTATUS RegFlushKey_Model(_In_ HKEY hKey)
{
	Message("RegFlushKey_Model\n");
	return 4;
}

static LSTATUS RegOpenKeyExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult)
{
	Message("RegOpenKeyExA_Model\n");
	return 4;
}

static LSTATUS RegQueryValueExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
	Message("RegQueryValueExA_Model\n");
	return 4;
}


static DWORD WINAPI SuspendThread_Model(HANDLE hThread) {
	Message("SuspendThread_Model\n");
	DWORD retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "SuspendThread_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static BOOL SetConsoleCtrlHandler_Model(_In_opt_ PHANDLER_ROUTINE HandlerRoutine, _In_ BOOL Add)
{
	Message("SetConsoleCtrlHandler_Model\n");
	return TRUE;
}

static BOOL SetEndOfFile_Model(_In_ HANDLE hFile)
{
	Message("SetEndOfFile_Model\n");
	return TRUE;
}

static BOOL SetEnvironmentVariableA_Model(_In_ LPCSTR lpName, _In_opt_ LPCSTR lpValue)
{
	Message("SetEnvironmentVariableA_Model\n");
	return TRUE;
}

static BOOL SetFileAttributesA_Model(_In_ LPCSTR lpFileName, _In_ DWORD dwFileAttributes)
{
	Message("SetFileAttributesA_Model\n");
	return TRUE;
}

static UINT SetHandleCount_Model(_In_ UINT uNumber)
{
	Message("SetHandleCount_Model\n");
	return 1u;
}

static BOOL SetStdHandle_Model(_In_ DWORD nStdHandle, _In_ HANDLE hHandle)
{
	Message("SetStdHandle_Model\n");
	return TRUE;
}

static LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter_Model(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
	Message("SetUnhandledExceptionFilter_Model\n");
	return NULL;
}

static BOOL SetCurrentDirectoryA_Model(_In_ LPCSTR lpPathName)
{
	Message("SetCurrentDirectoryA_Model\n");
	return TRUE;
}

static BOOL SetCurrentDirectoryW_Model(_In_ LPCWSTR lpPathName)
{
	Message("SetCurrentDirectoryW_Model\n");
	return TRUE;
}

static BOOL SetFileAttributesW_Model(_In_ LPCWSTR lpFileName, _In_ DWORD dwFileAttributes)
{
	Message("SetFileAttributesW_Model\n");
	return TRUE;
}

static DWORD SetFilePointer_Model(_In_ HANDLE hFile, _In_ LONG lDistanceToMove, _Inout_opt_ PLONG lpDistanceToMoveHigh, _In_ DWORD dwMoveMethod)
{
	Message("SetFilePointer_Model\n");
	return 1;
}

static BOOL SetFileTime_Model(_In_ HANDLE hFile, _In_opt_ const FILETIME* lpCreationTime, _In_opt_ const FILETIME* lpLastAccessTime, _In_opt_ const FILETIME* lpLastWriteTime)
{
	Message("SetFileTime_Model\n");
	return TRUE;
}

static VOID SetLastError_Model(_In_ DWORD dwErrCode)
{
	Message("SetLastError_Model\n");
	return;
}

static DWORD SizeofResource_Model(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo)
{
	Message("SizeofResource_Model\n");
	return 1;
}

static VOID Sleep_Model(_In_ DWORD dwMilliseconds)
{
	Message("Sleep_Model\n");
	return;
}

static int sprintf_Model(char* s, const char* format, ...)
{
	Message("sprintf_Model\n");
	return 1;
}

static void srand_Model(unsigned int seed)
{
	Message("srand_Model\n");
	return;
}

static BOOL StartServiceA_Model(_In_ SC_HANDLE hService, _In_ DWORD dwNumServiceArgs, LPCSTR* lpServiceArgVectors)
{
	Message("StartServiceA_Model\n");
	return TRUE;
}

static char* strcat_Model(char* dest, const char* src)
{
	Message("strcat_Model\n");
	return NULL;
}

static int strcmp_Model(const char* s1, const char* s2)
{
	Message("strcmp_Model\n");
	return 1;
}

static char* strcpy_Model(char* dest, const char* src)
{
	Message("strcpy_Model\n");
	return NULL;
}

static size_t strlen_Model(const char* s)
{
	Message("strlen_Model\n");
	return 1;
}

static char* strrchr_Model(char* s, int c)
{
	Message("strrchr_Model\n");
	return NULL;
}

static int swprintf_Model(wchar_t* s, size_t n, const wchar_t* format, ...)
{
	Message("swprintf_Model\n");
	return 1;
}

static BOOL SystemTimeToFileTime_Model(_In_ const SYSTEMTIME* lpSystemTime, _Out_ LPFILETIME lpFileTime)
{
	Message("SystemTimeToFileTime_Model\n");
	return TRUE;
}

static BOOL WINAPI Thread32First_Model(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {
	Message("Thread32First_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "Thread32First_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
static BOOL WINAPI Thread32Next_Model(HANDLE hSnapshot, LPTHREADENTRY32 lpte) {
	Message("Thread32Next_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "Thread32Next_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static BOOL TerminateProcess_Model(_In_ HANDLE hProcess, _In_ UINT uExitCode)
{
	Message("TerminateProcess_Model\n");
	return TRUE;
}
static LONG UnhandledExceptionFilter_Model(_In_ struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	Message("UnhandledExceptionFilter_Model\n");
	return 1;
}

static LPVOID VirtualAllocEx_Model(_In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect) {
	Message("VirtualAllocEx_Model\n");
	LPVOID retVal = NULL;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "VirtualAllocEx_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}

static LPVOID VirtualAlloc_Model(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect)
{
	Message("VirtualAlloc_Model\n");
	return NULL;
}

static BOOL VirtualFree_Model(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType)
{
	Message("VirtualFree_Model\n");
	return TRUE;
}

static BOOL VirtualProtect_Model(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect)
{
	Message("VirtualProtect_Model\n");
	return TRUE;
}

static BOOL WriteProcessMemory_Model(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T * lpNumberOfBytesWritten) {
	Message("WriteProcessMemory_Model\n");
	BOOL retVal = FALSE;
	if (trigger.compare("all") == 0)
	{
		S2EMakeSymbolic(&retVal, sizeof(retVal), "WriteProcessMemory_Model");
	}
	else
	{
		/* Concrete output */
	}
	
	/* Process memorysine bu yazildi gibi bir aciklama yazalim, anlamli olsun, bir cumle olsun */
	Message("[WriteProcessMemory_Model|evidence] {["); 
	unsigned char* cPtr = (unsigned char*)lpBuffer; 
	for (int i = 0; i < nSize; i++)
	{								
		Message("0x%x",cPtr[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
	}
	Message("]}\n");

	return retVal;
}

static int WideCharToMultiByte_Model(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCWCH lpWideCharStr, _In_ int cchWideChar, LPSTR lpMultiByteStr, _In_ int cbMultiByte, _In_opt_ LPCCH lpDefaultChar, _Out_opt_ LPBOOL lpUsedDefaultChar)
{
	Message("WideCharToMultiByte_Model\n");
	return 1;
}

static DWORD WaitForSingleObject_Model(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds)
{
	Message("WaitForSingleObject_Model\n");
	return 1;
}

static wchar_t* wcscat_Model(wchar_t* dest, const wchar_t* src)
{
	Message("wcscat_Model\n");
	return NULL;
}

static size_t wcslen_Model(const wchar_t* s)
{
	Message("wcslen_Model\n");
	return 1;
}

static wchar_t* wcsrchr_Model(wchar_t* wcs, wchar_t wc)
{
	Message("wcsrchr_Model\n");
	return NULL;
}

static BOOL WriteFile_Model(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped)
{
	Message("WriteFile_Model\n");
	return TRUE;
}

static int wsprintfA_Model(_Out_ LPSTR, _In_ LPCSTR, ...)
{
	Message("wsprintfA_Model\n");
	return 1;
}

int __cdecl __stdio_common_vfprintf_Model(_In_ unsigned __int64 Options, _Inout_ FILE * Stream, _In_z_ char const * Format, _In_opt_ _locale_t Locale, va_list ArgList) {
	Message("vfprintf_Model\n");
	Message("[vfprintf_Model|evidence] {[%s]}\n",Format);
	return 0;
}
int __cdecl __stdio_common_vfscanf_Model(_In_ unsigned __int64 Options, _Inout_ FILE * Stream, _In_z_ char const * Format, _In_opt_ _locale_t Locale, va_list Arglist) {
	Message("vfscanf_Model\n");
	return 0;
}
static int32_t _3f__3f_0exception_40__40_QAE_40_ABQBD_40_Z_Model(char** a1)
{
	Message("_3f__3f_0exception_40__40_QAE_40_ABQBD_40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_0exception_40__40_QAE_40_ABV0_40__40_Z_Model(int32_t* a1)
{
	Message("_3f__3f_0exception_40__40_QAE_40_ABV0_40__40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_1exception_40__40_UAE_40_XZ_Model(void)
{
	Message("_3f__3f_1exception_40__40_UAE_40_XZ_Model\n");
	return 1u;
}

static int32_t _3f__3f_1type_info_40__40_UAE_40_XZ_Model(void)
{
	Message("_3f__3f_1type_info_40__40_UAE_40_XZ_Model\n");
	return 1u;
}

static int32_t _3f__3f_2_40_YAPAXI_40_Z_Model(int32_t a1)
{
	Message("_3f__3f_2_40_YAPAXI_40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_3_40_YAXPAX_40_Z_Model(int32_t* a1)
{
	Message("_3f__3f_3_40_YAXPAX_40_Z_Model\n");
	return 1u;
}

//static EXCEPTION_DISPOSITION __CxxFrameHandler_Model(EHExceptionRecord* pExcept, EHRegistrationNode* pRN, void* pContext, DispatcherContext* pDC)
//{
//	Message("__CxxFrameHandler_Model\n");
//	return NULL; /* cok emin degilim */
//}


/* stuxnet degil */
static int __getmainargs_Model(int* Argc, char*** Argv, char*** Env, int DoWildCard, _startupinfo* StartInfo)
{
	Message("__getmainargs_Model\n");
	return 1;
}

static int* __cdecl __p___argc_Model(void)
{
	Message("__cdecl __p___argc_Model\n");
	return NULL;
}

static char*** __cdecl __p___argv_Model(void)
{
	Message("__cdecl __p___argv_Model\n");
	return NULL;
}

static int* __cdecl __p__commode_Model(void)
{
	Message("__cdecl __p__commode_Model\n");
	return NULL;
}

static int* __cdecl __p__fmode_Model(void)
{
	Message("__cdecl __p__fmode_Model\n");
	return NULL;
}

static void __set_app_type_Model(int at)
{
	Message("__set_app_type_Model\n");
	return;
}

/* stuxnet degil */
static void __setusermatherr_Model(_HANDLE_MATH_ERROR pf)
{
	Message("__setusermatherr_Model\n");
	return;
}

static unsigned int __cdecl _controlfp_Model(_In_ unsigned int NewValue, _In_ unsigned int Mask)
{
	Message("int __cdecl _controlfp_Model\n");
	return 1u; /* Hopefully types continues with int, char..etc. */
}

/* stuxnet degil */
static void __stdcall _CxxThrowException_Model(void* pExceptionObject, _ThrowInfo* pThrowInfo)
{
	Message("__stdcall _CxxThrowException_Model\n");
	return;
}


/* stuxnet degil */
static int _except_handler3_Model(PEXCEPTION_RECORD exception_record, PEXCEPTION_REGISTRATION registration, PCONTEXT context, PEXCEPTION_REGISTRATION dispatcher)
{
	Message("_except_handler3_Model\n");
	return 1;
}


/* stuxnet degil */
static void __cdecl _initterm_Model(_In_ _PVFV* First, _In_ _PVFV* Last)
{
	Message("__cdecl _initterm_Model\n");
	return;
}

/* stuxnet degil */
static void _local_unwind2_Model(PEXCEPTION_REGISTRATION xr, int stop)
{
	Message("_local_unwind2_Model\n");
	return;
}

static unsigned char _CONST_RETURN* __cdecl _mbsstr_Model(_In_z_ unsigned char const* Str, _In_z_ unsigned char const* Substr)
{
	Message("char _CONST_RETURN* __cdecl _mbsstr_Model\n");
	return 0; /* Hopefully types continues with int, char..etc. */
}

static int __cdecl _stricmp_Model(_In_z_ char const* String1, _In_z_ char const* String2)
{
	Message("__cdecl _stricmp_Model\n");
	return 1;
}

static int _XcptFilter_Model(unsigned long xcptnum, void* pxcptinfoptrs)
{
	Message("_XcptFilter_Model\n");
	return 1;
}
int getchar_Model(void) {
	Message("getchar_Model\n");
	int retVal = 0;
	if (trigger.compare("all") == 0)
	{
		//S2EMakeSymbolic(&retVal, sizeof(retVal), "WriteProcessMemory_Model");
	}
	else
	{
		/* Concrete output */
	}
	return retVal;
}
 

// The names of the functions to hook (and the library they belong to)
static LPCSTR functionsToHook[][2] = {
	{ "kernel32", "GetLocalTime" } ,
	{ "kernel32", "CloseHandle" } ,
	{ "kernel32", "CreateToolhelp32Snapshot" } ,
	{ "kernel32", "CreateRemoteThread" } ,
	{ "kernel32", "FormatMessageW" } ,
	{ "kernel32", "GetLastError" } ,
	{ "kernel32", "GetModuleHandleW" } ,
	{ "kernel32", "GetPriorityClass" } ,
	{ "kernel32", "GetProcAddress" } ,	
	{ "kernel32", "OpenProcess" } ,
	{ "kernel32", "OpenThread" } ,
	{ "kernel32", "Process32FirstW" } ,
	{ "kernel32", "Process32NextW" } ,
	{ "kernel32", "ResumeThread" } ,
	{ "kernel32", "SuspendThread" } ,
	{ "kernel32", "Thread32First" } ,
	{ "kernel32", "Thread32Next" } ,
	{ "kernel32", "VirtualAllocEx" } ,
	{ "kernel32", "WriteProcessMemory" } ,
	{ "ucrtbase", "__stdio_common_vfprintf" } ,
	{ "ucrtbase", "__stdio_common_vfscanf" } ,
	{ "ucrtbase", "getchar" } ,
	{ NULL, NULL },
};

// The function hooks that we will install
static PVOID hookFunctions[] = {
	GetLocalTime_Model,
	CloseHandle_Model,
	CreateToolhelp32Snapshot_Model,
	CreateRemoteThread_Model,
	FormatMessageW_Model,
	GetLastError_Model,
	GetModuleHandleW_Model,
	GetPriorityClass_Model,
	GetProcAddress_Model,
	OpenProcess_Model,
	OpenThread_Model,
	Process32FirstW_Model,
	Process32NextW_Model,
	ResumeThread_Model,
	SuspendThread_Model,
	Thread32First_Model,
	Thread32Next_Model,
	VirtualAllocEx_Model,
	WriteProcessMemory_Model,
	__stdio_common_vfprintf_Model,
	__stdio_common_vfscanf_Model,
	getchar_Model,
};

// The actual hooks
static HOOK_TRACE_INFO hooks[] = {
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
};



// EasyHook will be looking for this export to support DLL injection. If not
// found then DLL injection will fail
extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO *);

void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO *inRemoteInfo) {
	// Unused
	(void*)inRemoteInfo;	
	// Used by the Message function to decide where to write output to
	s2eVersion = S2EGetVersion();

	/* Check trigger sources */
	// Create a text string, which is used to output the text file

	// Read from the text file
	ifstream triggerFile("trigger.txt");

	// Use a while loop together with the getline() function to read the file line by line
	while (getline(triggerFile, trigger)) {
		// Output the text from the file
		Message(trigger.c_str());
	}

	// Close the file
	triggerFile.close();

	// TODO initialize hooks
	// Replace the previous TODO with the following code to install the
	// GetLocalTime hook
	for (unsigned i = 0; functionsToHook[i][0] != NULL; ++i) {
		LPCSTR moduleName = functionsToHook[i][0];
		LPCSTR functionName = functionsToHook[i][1];

		// Install the hook
		NTSTATUS result = LhInstallHook(
			GetProcAddress(GetModuleHandleA(moduleName), functionName),
			hookFunctions[i],
			NULL,
			&hooks[i]);

		if (FAILED(result)) {
			Message("Failed to hook %s.%s: %S at %d\n", moduleName, functionName,
				RtlGetLastErrorString(),i);
		}
		else {
			Message("Successfully hooked %s.%s at %d\n", moduleName, functionName,i);
		}

		// Ensure that all threads _except_ the injector thread will be hooked
		ULONG ACLEntries[1] = { 0 };
		LhSetExclusiveACL(ACLEntries, 1, &hooks[i]);
	}


	// The process was started in a suspended state. Wake it up...
	RhWakeUpProcess();
}

//
//static KIRQL KeGetCurrentIrql_Model(VOID)
//{
//	Message("KeGetCurrentIrql_Model\n");
//	return 0;
//}
//
//static PKTHREAD KeGetCurrentThread_Model(VOID)
//{
//	Message("KeGetCurrentThread_Model\n");
//	return NULL;
//}
//
//static VOID KeInitializeMutex_Model(_Out_ PRKMUTEX Mutex, _In_ ULONG Level)
//{
//	Message("KeInitializeMutex_Model\n");
//	return;
//}
//
//static LONG KeReleaseMutex_Model(_Inout_ PRKMUTEX Mutex, _In_ BOOLEAN Wait)
//{
//	Message("KeReleaseMutex_Model\n");
//	return 1;
//}
//
//static NTSTATUS KeWaitForSingleObject_Model(_In_ PVOID Object, _In_ KWAIT_REASON WaitReason, _In_ KPROCESSOR_MODE WaitMode, _In_ BOOLEAN Alertable, _In_opt_ PLARGE_INTEGER Timeout)
//{
//	Message("KeWaitForSingleObject_Model\n");
//	return 0;
//}
//
//static KIRQL FASTCALL KfAcquireSpinLock_Model(_Inout_ PKSPIN_LOCK SpinLock)
//{
//	Message("FASTCALL KfAcquireSpinLock_Model\n");
//	return 0;
//}
//
//static VOID FASTCALL KfReleaseSpinLock_Model(_Inout_ PKSPIN_LOCK SpinLock, _In_ KIRQL NewIrql)
//{
//	Message("FASTCALL KfReleaseSpinLock_Model\n");
//	return;
//}
//
//static LONG_PTR FASTCALL ObfDereferenceObject_Model(_In_ PVOID Object)
//{
//	Message("FASTCALL ObfDereferenceObject_Model\n");
//	return NULL;
//}
//
//static NTSTATUS ObOpenObjectByPointer_Model(_In_ PVOID Object, _In_ ULONG HandleAttributes, _In_opt_ PACCESS_STATE PassedAccessState, _In_ ACCESS_MASK DesiredAccess, _In_opt_ POBJECT_TYPE ObjectType, _In_ KPROCESSOR_MODE AccessMode, _Out_ PHANDLE Handle)
//{
//	Message("ObOpenObjectByPointer_Model\n");
//	return 0;
//}
//
//
//static BOOLEAN PsGetVersion_Model(_Out_opt_ PULONG MajorVersion, _Out_opt_ PULONG MinorVersion, _Out_opt_ PULONG BuildNumber, _Out_opt_ PUNICODE_STRING CSDVersion)
//{
//	Message("PsGetVersion_Model\n");
//	return TRUE;
//}
//
//static NTSTATUS PsLookupProcessByProcessId_Model(_In_ HANDLE ProcessId, PEPROCESS* Process)
//{
//	Message("PsLookupProcessByProcessId_Model\n");
//	return 0;
//}
//
//
//static PHYSICAL_ADDRESS MmGetPhysicalAddress_Model(_In_ PVOID BaseAddress)
//{
//	Message("MmGetPhysicalAddress_Model\n");
//	return 0;
//}
//
//static PVOID MmGetSystemRoutineAddress_Model(_In_ PUNICODE_STRING SystemRoutineName)
//{
//	Message("MmGetSystemRoutineAddress_Model\n");
//	return NULL;
//}
//
//static PVOID MmMapIoSpace_Model(_In_ PHYSICAL_ADDRESS PhysicalAddress, _In_ SIZE_T NumberOfBytes, _In_ MEMORY_CACHING_TYPE CacheType)
//{
//	Message("MmMapIoSpace_Model\n");
//	return NULL;
//}
//
//static VOID MmUnmapIoSpace_Model(PVOID BaseAddress, _In_ SIZE_T NumberOfBytes)
//{
//	Message("MmUnmapIoSpace_Model\n");
//	return;
//}
//
// 
// static NTSTATUS ZwClose_Model(_In_ HANDLE Handle)
// {
// 	Message("ZwClose_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwOpenFile_Model(_Out_ PHANDLE FileHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes, _Out_ PIO_STATUS_BLOCK IoStatusBlock, _In_ ULONG ShareAccess, _In_ ULONG OpenOptions)
// {
// 	Message("ZwOpenFile_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwOpenKey_Model(_Out_ PHANDLE KeyHandle, _In_ ACCESS_MASK DesiredAccess, _In_ POBJECT_ATTRIBUTES ObjectAttributes)
// {
// 	Message("ZwOpenKey_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwQueryInformationFile_Model(_In_ HANDLE FileHandle, _Out_ PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, _In_ ULONG Length, _In_ FILE_INFORMATION_CLASS FileInformationClass)
// {
// 	Message("ZwQueryInformationFile_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwQueryInformationProcess_Model(_In_ HANDLE ProcessHandle, _In_ PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, _In_ ULONG ProcessInformationLength, _Out_opt_ PULONG ReturnLength)
// {
// 	Message("ZwQueryInformationProcess_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwQueryValueKey_Model(_In_ HANDLE KeyHandle, _In_ PUNICODE_STRING ValueName, _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, _In_ ULONG Length, PULONG ResultLength)
// {
// 	Message("ZwQueryValueKey_Model\n");
// 	return 0;
// }
// 
// static NTSTATUS ZwReadFile_Model(_In_ HANDLE FileHandle, _In_opt_ HANDLE Event, _In_opt_ PIO_APC_ROUTINE ApcRoutine, _In_opt_ PVOID ApcContext, _Out_ PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, _In_ ULONG Length, _In_opt_ PLARGE_INTEGER ByteOffset, _In_opt_ PULONG Key)
// {
// 	Message("ZwReadFile_Model\n");
// 	return 0;
// }
//
//static PIO_WORKITEM IoAllocateWorkItem_Model(_In_ PDEVICE_OBJECT DeviceObject)
//{
//	Message("IoAllocateWorkItem_Model\n");
//	return NULL;
//}
//
//static PDEVICE_OBJECT IoAttachDeviceToDeviceStack_Model(_In_ PDEVICE_OBJECT SourceDevice, _In_ PDEVICE_OBJECT TargetDevice)
//{
//	Message("IoAttachDeviceToDeviceStack_Model\n");
//	return NULL;
//}
//
//static NTSTATUS IoCreateDevice_Model(_In_ PDRIVER_OBJECT DriverObject, _In_ ULONG DeviceExtensionSize, _In_opt_ PUNICODE_STRING DeviceName, _In_ DEVICE_TYPE DeviceType, _In_ ULONG DeviceCharacteristics, _In_ BOOLEAN Exclusive, PDEVICE_OBJECT* DeviceObject)
//{
//	Message("IoCreateDevice_Model\n");
//	return 0;
//}
//
//static NTSTATUS IoCreateSymbolicLink_Model(_In_ PUNICODE_STRING SymbolicLinkName, _In_ PUNICODE_STRING DeviceName)
//{
//	Message("IoCreateSymbolicLink_Model\n");
//	return 0;
//}
//
//static VOID IoDeleteDevice_Model(_In_ PDEVICE_OBJECT DeviceObject)
//{
//	Message("IoDeleteDevice_Model\n");
//	return;
//}
//
//static NTSTATUS IoDeleteSymbolicLink_Model(_In_ PUNICODE_STRING SymbolicLinkName)
//{
//	Message("IoDeleteSymbolicLink_Model\n");
//	return 0;
//}
//
//static VOID IofCompleteRequest_Model(_In_ PIRP Irp, _In_ CCHAR PriorityBoost)
//{
//	Message("FASTCALL IofCompleteRequest_Model\n");
//	return;
//}
//
//static VOID IoFreeWorkItem_Model(_In_ PIO_WORKITEM IoWorkItem)
//{
//	Message("IoFreeWorkItem_Model\n");
//	return;
//}
//
//static VOID IoInitializeRemoveLockEx_Model(_Out_ PIO_REMOVE_LOCK Lock, _In_ ULONG AllocateTag, _In_ ULONG MaxLockedMinutes, _In_ ULONG HighWatermark, _In_ ULONG RemlockSize)
//{
//	Message("IoInitializeRemoveLockEx_Model\n");
//	return;
//}
//
//static VOID IoQueueWorkItem_Model(_Inout_ PIO_WORKITEM IoWorkItem, _In_ PIO_WORKITEM_ROUTINE WorkerRoutine, _In_ WORK_QUEUE_TYPE QueueType, _In_opt_ PVOID Context)
//{
//	Message("IoQueueWorkItem_Model\n");
//	return;
//}
//
//static VOID IoRegisterDriverReinitialization_Model(_In_ PDRIVER_OBJECT DriverObject, _In_ PDRIVER_REINITIALIZE DriverReinitializationRoutine, _In_opt_ PVOID Context)
//{
//	Message("IoRegisterDriverReinitialization_Model\n");
//	return;
//}
//

/* stuxnet degil */
static VOID RtlUnwind_Model(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue)
{
	Message("RtlUnwind_Model\n");
	return;
}

// 
// 
// static BOOLEAN RtlDeleteElementGenericTable_Model(_In_ PRTL_GENERIC_TABLE Table, _In_ PVOID Buffer)
// {
// 	Message("RtlDeleteElementGenericTable_Model\n");
// 	return TRUE;
// }
// 
// static VOID RtlInitializeGenericTable_Model(_Out_ PRTL_GENERIC_TABLE Table, _In_ PRTL_GENERIC_COMPARE_ROUTINE CompareRoutine, _In_ PRTL_GENERIC_ALLOCATE_ROUTINE AllocateRoutine, _In_ PRTL_GENERIC_FREE_ROUTINE FreeRoutine, _In_opt_ PVOID TableContext)
// {
// 	Message("RtlInitializeGenericTable_Model\n");
// 	return;
// }
// 
// static VOID RtlInitUnicodeString_Model(PUNICODE_STRING DestinationString, PCWSTR SourceString)
// {
// 	Message("RtlInitUnicodeString_Model\n");
// 	return;
// }
// 
// static PVOID RtlInsertElementGenericTable_Model(_In_ PRTL_GENERIC_TABLE Table, PVOID Buffer, _In_ CLONG BufferSize, _Out_opt_ PBOOLEAN NewElement)
// {
// 	Message("RtlInsertElementGenericTable_Model\n");
// 	return NULL;
// }
// 
// static PVOID RtlLookupElementGenericTable_Model(_In_ PRTL_GENERIC_TABLE Table, _In_ PVOID Buffer)
// {
// 	Message("RtlLookupElementGenericTable_Model\n");
// 	return NULL;
// }
// 
// static WCHAR RtlUpcaseUnicodeChar_Model(_In_ WCHAR SourceCharacter)
// {
// 	Message("RtlUpcaseUnicodeChar_Model\n");
// 	return 0x48;
// }