// malware-hook.cpp : Defines the exported functions for the DLL application.
//

#include "stdafx.h"
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <string>
#include <strsafe.h>
#include <tlhelp32.h> /* Process32NextW gibi.. */
#include <easyhook.h>
#include <atlstr.h>
#include <wincrypt.h>

#if _WIN64
#pragma comment(lib, "EasyHook64.lib")
#else
#pragma comment(lib, "EasyHook32.lib")
#endif

#pragma comment(lib, "libcommon.lib")

#define USER_APP
extern "C"
{
#include <s2e/s2e.h>
}

#define S2E_MSG_LEN 512

static INT s2eVersion = 0;

using namespace std;
static string detail;

static void Message(LPCSTR fmt, ...)
{
	CHAR message[S2E_MSG_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(message, S2E_MSG_LEN, fmt, args);
	va_end(args);

	if (s2eVersion)
	{
		S2EMessageFmt("[Logger|HOOK] %s", message);
	}
	else
	{
		printf("[Logger|HOOK] %s", message);
	}
}

/* ---------------------------------------- MODELS START ---------------------------------------- */

static int __cdecl __stdio_common_vfprintf_Model(_In_ unsigned __int64 Options, _Inout_ FILE *Stream, _In_z_ char const *Format, _In_opt_ _locale_t Locale, va_list ArgList)
{
	Message("vfprintf_Model\n");
	char buffer[1024] = { "\0" };
	vsnprintf(buffer, sizeof(buffer)-1,Format, ArgList);
	Message("[vfprintf_Model|evidence] {[%s]}\n", buffer);
	return 0;
}

static int __cdecl __stdio_common_vfscanf_Model(_In_ unsigned __int64 Options, _Inout_ FILE *Stream, _In_z_ char const *Format, _In_opt_ _locale_t Locale, va_list Arglist)
{
	Message("vfscanf_Model\n");
	return 0;
}

static BOOL WINAPI CloseHandle_Model(HANDLE hObject)
{
	Message("CloseHandle_Model\n");
	BOOL retVal = TRUE;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "CloseHandle_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static HANDLE CreateRemoteThread_Model(_In_ HANDLE hProcess, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId)
{
	Message("CreateRemoteThread_Model\n");
	Message("[CreateRemoteThread_Model|info] {[RETVAL]}\n");
	HANDLE retVal = (HANDLE)1;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "CreateRemoteThread_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static HANDLE WINAPI CreateToolhelp32Snapshot_Model(DWORD dwFlags, DWORD th32ProcessID)
{
	Message("CreateToolhelp32Snapshot_Model\n");
	HANDLE retVal = NULL;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "CreateToolhelp32Snapshot_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}


static BOOL CloseServiceHandle_Model(_In_ SC_HANDLE hSCObject)
{
	Message("CloseServiceHandle_Model\n");
	return TRUE;
}

static BOOL CopyFileA_Model(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists)
{
	Message("CopyFileA_Model\n");
	return TRUE;
}

static BOOL CreateDirectoryA_Model(_In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	Message("CreateDirectoryA_Model\n");
	return TRUE;
}

static BOOL CreateDirectoryW_Model(_In_ LPCWSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	Message("CreateDirectoryW_Model\n");
	return TRUE;
}


static BOOL CreateProcessA_Model(_In_opt_ LPCSTR lpApplicationName, _Inout_opt_ LPSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCSTR lpCurrentDirectory, _In_ LPSTARTUPINFOA lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation)
{
	Message("CreateProcessA_Model\n");
	Message("[CreateProcessA_Model|evidence] {[Create Process '%s', with command line: '%s', in current directory '%s']}\n",lpApplicationName,lpCommandLine,lpCurrentDirectory);
	return TRUE;
}

static BOOL CryptReleaseContext_Model(_In_ HCRYPTPROV hProv, _In_ DWORD dwFlags)
{
	Message("CryptReleaseContext_Model\n");
	return TRUE;
}

static BOOL DeleteFileW_Model(_In_ LPCWSTR lpFileName)
{
	Message("DeleteFileW_Model\n");
	return TRUE;
}
static DWORD WINAPI FormatMessageW_Model(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, _Out_ LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
{
	Message("FormatMessageW_Model\n");
	DWORD retVal = 0;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "FormatMessageW_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static int getchar_Model(void)
{
	Message("getchar_Model\n");
	int retVal = 0;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "WriteProcessMemory_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static DWORD WINAPI GetLastError_Model(VOID)
{
	Message("GetLastError_Model\n");
	Message("[GetLastError_Model|info] {[APICALL]}\n");
	DWORD retVal = GetLastError();
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetLastError_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static void WINAPI GetLocalTime_Model(LPSYSTEMTIME lpSystemTime)
{
	Message("GetLocalTime_Model\n");
	Message("[GetLocalTime_Model|info] {[SYMBOLIC]}\n");
	// Call the original GetLocalTime to get a concrete value
	GetLocalTime(lpSystemTime);

	// Make the value concolic
	S2EMakeSymbolic(lpSystemTime, sizeof(*lpSystemTime), "LocalTime");

	return;
}

static HMODULE GetModuleHandleW_Model(_In_opt_ LPCWSTR lpModuleName)
{
	Message("GetModuleHandleW_Model\n");
	HMODULE retVal = NULL;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetModuleHandleW_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	//
	Message("[GetModuleHandleW_Model|info] {[RETVAL]}");
	retVal = (HMODULE)1;/*not null*///GetModuleHandleW(lpModuleName);
	Message("[GetModuleHandleW_Model|evidence] {[Get the handle for the module: '%s']}", CW2A(lpModuleName));
	return retVal;
}

static DWORD WINAPI GetPriorityClass_Model(HANDLE hProcess)
{
	Message("GetPriorityClass_Model\n");
	DWORD retVal = 0;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetPriorityClass_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static FARPROC GetProcAddress_Model(_In_ HMODULE hModule, _In_ LPCSTR lpProcName)
{
	Message("GetProcAddress_Model\n");
	Message("[GetProcAddress_Model|info] {[RETVAL]}\n");
	Message("[GetProcAddress_Model|evidence] {[Retrieve the function: '%s' from a DLL file]}\n", lpProcName);
	FARPROC retVal = (FARPROC)1; /*otherthan null*/ //GetProcAddress(hModule,lpProcName);
; /* null disinda herhangi bir sey */
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "GetProcAddress_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static DWORD GetProcessId_Model(_In_ HANDLE Process)
{
	Message("GetProcessId_Model\n");
	return 1;
}
static HANDLE WINAPI OpenProcess_Model(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
	Message("OpenProcess_Model\n");
	Message("[OpenProcess_Model|info] {[RETVAL]}", dwProcessId);
	Message("[OpenProcess_Model|evidence] {[Open process with ID: %d]}", dwProcessId);
	HANDLE retVal = (HANDLE)1; /* other than null*/
	//if (detail.compare("all") == 0)
	//{
	//	S2EMakeSymbolic(&retVal, sizeof(retVal), "OpenProcess_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static HANDLE WINAPI OpenThread_Model(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
{
	Message("OpenThread_Model\n");
	Message("[OpenThread_Model|evidence] {[DesiredAccess: %d,\
										   Does it inherit handle?(0:false/1:true): %d,\
										   Thread Id: %d}]\n",dwDesiredAccess,bInheritHandle,dwThreadId);
	HANDLE retVal = NULL;
	//if (detail.compare("all") == 0)
	//{
	//	S2EMakeSymbolic(&retVal, sizeof(retVal), "OpenThread_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static BOOL WINAPI Process32FirstW_Model(HANDLE hSnapshot, LPPROCESSENTRY32W lppe)
{
	Message("Process32FirstW_Model\n");
	BOOL retVal = FALSE;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "Process32FirstW_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static BOOL WINAPI Process32NextW_Model(HANDLE hSnapshot, LPPROCESSENTRY32W lppe)
{
	Message("Process32NextW_Model\n");
	BOOL retVal = FALSE;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "Process32NextW_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static DWORD WINAPI ResumeThread_Model(HANDLE hThread)
{
	Message("ResumeThread_Model\n");
	DWORD retVal = 0;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "ResumeThread_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static DWORD WINAPI SuspendThread_Model(HANDLE hThread)
{
	Message("SuspendThread_Model\n");
	DWORD retVal = 0;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "SuspendThread_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static BOOL SHGetSpecialFolderPathA_Model(HWND hwnd, LPSTR pszPath, _In_ int csidl, _In_ BOOL fCreate)
{
	Message("SHGetSpecialFolderPathA_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static BOOL WINAPI Thread32First_Model(HANDLE hSnapshot, LPTHREADENTRY32 lpte)
{
	Message("Thread32First_Model\n");
	BOOL retVal = FALSE;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "Thread32First_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}
static BOOL WINAPI Thread32Next_Model(HANDLE hSnapshot, LPTHREADENTRY32 lpte)
{
	Message("Thread32Next_Model\n");
	BOOL retVal = FALSE;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "Thread32Next_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static LPVOID VirtualAllocEx_Model(_In_ HANDLE hProcess, _In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect)
{
	Message("VirtualAllocEx_Model\n");
	Message("[VirtualAllocEx_Model|info] {[RETVAL]}");
	Message("[VirtualAllocEx_Model|evidence] {[Allocation size: %u, allocation type: 0x%x, protections: 0x%x]}\n", dwSize, flAllocationType, flProtect);
	LPVOID retVal = (LPVOID)1;
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(&retVal, sizeof(retVal), "VirtualAllocEx_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static BOOL WriteProcessMemory_Model(_In_ HANDLE hProcess, _In_ LPVOID lpBaseAddress, LPCVOID lpBuffer, _In_ SIZE_T nSize, _Out_opt_ SIZE_T *lpNumberOfBytesWritten)
{
	Message("WriteProcessMemory_Model\n");
	Message("[WriteProcessMemory_Model|info] {[RETVAL]}");
	BOOL retVal = TRUE;
	//if (detail.compare("all") == 0)
	//{
	//	S2EMakeSymbolic(&retVal, sizeof(retVal), "WriteProcessMemory_Model");
	//}
	//else
	//{
	//	/* Concrete output */
	//}

	/* Process memorysine bu yazildi gibi bir aciklama yazalim, anlamli olsun, bir cumle olsun */
	Message("[WriteProcessMemory_Model|evidence] {[ Data written to the process memory: ");
	unsigned char *cPtr = (unsigned char *)lpBuffer;
	for (int i = 0; i < nSize; i++)
	{
		Message("0x%x", cPtr[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
	}
	Message("in ASCII format \"");
	for (int i = 0; i < nSize; i++)
	{
		if ((cPtr[i] >= 0x22) && (cPtr[i] <= 0x7E))
		{
			Message("%c", cPtr[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
		}
		else
		{
			Message("[NON-ASCII]", cPtr[i]); 
		}
	}
	Message("\"]}\n");

	return retVal;
}

static BOOL FreeEnvironmentStringsA_Model(_In_ LPCH penv)
{
	Message("FreeEnvironmentStringsA_Model\n");
	return TRUE;
}

static BOOL FreeEnvironmentStringsW_Model(_In_ LPWCH penv)
{
	Message("FreeEnvironmentStringsW_Model\n");
	return TRUE;
}

static BOOL FreeLibrary_Model(_In_ HMODULE hLibModule)
{
	Message("FreeLibrary_Model\n");
	return TRUE;
}

static BOOL GetComputerNameW_Model(LPWSTR lpBuffer, _Inout_ LPDWORD nSize)
{
	Message("GetComputerNameW_Model\n");
	Message("[GetComputerNameW_Model|info] {[APICALL]}\n");
	BOOL retVal = GetComputerNameW(lpBuffer, nSize);
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(lpBuffer, sizeof(nSize), "GetComputerNameW_Model"); /* OUT VARIABLE */
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static BOOL GetCPInfo_Model(_In_ UINT CodePage, _Out_ LPCPINFO lpCPInfo)
{
	Message("GetCPInfo_Model\n");
	return TRUE;
}

static BOOL GetExitCodeProcess_Model(_In_ HANDLE hProcess, _Out_ LPDWORD lpExitCode)
{
	Message("GetExitCodeProcess_Model\n");
	BOOL retVal = TRUE;
	//if (detail.compare("all") == 0)
	//{
	//	Message("[GetExitCodeProcess_Model|info] {[APICALL]}\n");
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return retVal;
}

static BOOL GetFileSizeEx_Model(_In_ HANDLE hFile, _Out_ PLARGE_INTEGER lpFileSize)
{
	Message("GetFileSizeEx_Model\n");
	return TRUE;
}

static BOOL GetStringTypeA_Model(_In_ LCID Locale, _In_ DWORD dwInfoType, LPCSTR lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType)
{
	Message("GetStringTypeA_Model\n");
	return TRUE;
}

static BOOL GetStringTypeW_Model(_In_ DWORD dwInfoType, LPCWCH lpSrcStr, _In_ int cchSrc, _Out_ LPWORD lpCharType)
{
	Message("GetStringTypeW_Model\n");
	return TRUE;
}

static BOOL GetTokenInformation_Model(_In_ HANDLE TokenHandle, _In_ TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, _In_ DWORD TokenInformationLength, _Out_ PDWORD ReturnLength)
{
	Message("GetTokenInformation_Model\n");
	return TRUE;
}

static BOOL HeapDestroy_Model(_In_ HANDLE hHeap)
{
	Message("HeapDestroy_Model\n");
	return TRUE;
}

static BOOL HeapFree_Model(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem)
{
	Message("HeapFree_Model\n");
	return TRUE;
}

static BOOL IsBadCodePtr_Model(_In_opt_ FARPROC lpfn)
{
	Message("IsBadCodePtr_Model\n");
	return TRUE;
}

static BOOL IsBadReadPtr_Model(_In_opt_ const VOID* lp, _In_ UINT_PTR ucb)
{
	Message("IsBadReadPtr_Model\n");
	return TRUE;
}

static BOOL IsBadWritePtr_Model(_In_opt_ LPVOID lp, _In_ UINT_PTR ucb)
{
	Message("IsBadWritePtr_Model\n");
	return TRUE;
}

static BOOL LocalFileTimeToFileTime_Model(_In_ const FILETIME* lpLocalFileTime, _Out_ LPFILETIME lpFileTime)
{
	Message("LocalFileTimeToFileTime_Model\n");
	return TRUE;
}

static BOOL LookupPrivilegeValueA_Model(_In_opt_ LPCSTR lpSystemName, _In_ LPCSTR lpName, _Out_ PLUID lpLuid)
{
	Message("LookupPrivilegeValueA_Model\n");
	return TRUE;
}

static BOOL MoveFileA_Model(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName)
{
	Message("MoveFileA_Model\n");
	return TRUE;
}

static BOOL MoveFileExA_Model(_In_ LPCSTR lpExistingFileName, _In_opt_ LPCSTR lpNewFileName, _In_ DWORD dwFlags)
{
	Message("MoveFileExA_Model\n");
	return TRUE;
}

static BOOL OpenProcessToken_Model(_In_ HANDLE ProcessHandle, _In_ DWORD DesiredAccess, PHANDLE TokenHandle)
{
	Message("OpenProcessToken_Model\n");
	return TRUE;
}

static BOOL QueryPerformanceCounter_Model(_Out_ LARGE_INTEGER* lpPerformanceCount)
{
	Message("QueryPerformanceCounter_Model\n");
	return TRUE;
}

static BOOL QueryPerformanceFrequency_Model(_Out_ LARGE_INTEGER* lpFrequency)
{
	Message("QueryPerformanceFrequency_Model\n");
	return TRUE;
}

static BOOL QueryServiceStatus_Model(_In_ SC_HANDLE hService, _Out_ LPSERVICE_STATUS lpServiceStatus)
{
	Message("QueryServiceStatus_Model\n");
	return TRUE;
}

static BOOL ReadFile_Model(_In_ HANDLE hFile, LPVOID lpBuffer, _In_ DWORD nNumberOfBytesToRead, _Out_opt_ LPDWORD lpNumberOfBytesRead, _Inout_opt_ LPOVERLAPPED lpOverlapped)
{
	Message("ReadFile_Model\n");
	return TRUE;
}

static BOOL SetConsoleCtrlHandler_Model(_In_opt_ PHANDLER_ROUTINE HandlerRoutine, _In_ BOOL Add)
{
	Message("SetConsoleCtrlHandler_Model\n");
	return TRUE;
}

static BOOL SetCurrentDirectoryA_Model(_In_ LPCSTR lpPathName)
{
	Message("SetCurrentDirectoryA_Model\n");
	//Message("[SetCurrentDirectoryA_Model|info] {[SYMBOLIC]}\n");
	if (lpPathName != NULL)
	{
		Message("[SetCurrentDirectoryA_Model|evidence] {[Set current directory to '%s']}\n", lpPathName);
	}

	BOOL retVal = TRUE;
	//if (detail.compare("all") == 0)
	//{
	//	S2EMakeSymbolic(&retVal, sizeof(retVal), "SetCurrentDirectoryA_Model"); /* OUT VARIABLE */
	//}
	//else
	//{
	//	/* Concrete output */
	//}

	return retVal;
}

static BOOL SetCurrentDirectoryW_Model(_In_ LPCWSTR lpPathName)
{
	Message("SetCurrentDirectoryW_Model\n");
	return TRUE;
}

static BOOL SetEndOfFile_Model(_In_ HANDLE hFile)
{
	Message("SetEndOfFile_Model\n");
	return TRUE;
}

static BOOL SetEnvironmentVariableA_Model(_In_ LPCSTR lpName, _In_opt_ LPCSTR lpValue)
{
	Message("SetEnvironmentVariableA_Model\n");
	return TRUE;
}

static BOOL SetFileAttributesA_Model(_In_ LPCSTR lpFileName, _In_ DWORD dwFileAttributes)
{
	Message("SetFileAttributesA_Model\n");
	return TRUE;
}

static BOOL SetFileAttributesW_Model(_In_ LPCWSTR lpFileName, _In_ DWORD dwFileAttributes)
{
	Message("SetFileAttributesW_Model\n");
	return TRUE;
}

static BOOL SetFileTime_Model(_In_ HANDLE hFile, _In_opt_ const FILETIME* lpCreationTime, _In_opt_ const FILETIME* lpLastAccessTime, _In_opt_ const FILETIME* lpLastWriteTime)
{
	Message("SetFileTime_Model\n");
	return TRUE;
}

static BOOL SetStdHandle_Model(_In_ DWORD nStdHandle, _In_ HANDLE hHandle)
{
	Message("SetStdHandle_Model\n");
	return TRUE;
}

static BOOL StartServiceA_Model(_In_ SC_HANDLE hService, _In_ DWORD dwNumServiceArgs, LPCSTR* lpServiceArgVectors)
{
	Message("StartServiceA_Model\n");
	return TRUE;
}

static BOOL SystemTimeToFileTime_Model(_In_ const SYSTEMTIME* lpSystemTime, _Out_ LPFILETIME lpFileTime)
{
	Message("SystemTimeToFileTime_Model\n");
	return TRUE;
}

static BOOL TerminateProcess_Model(_In_ HANDLE hProcess, _In_ UINT uExitCode)
{
	Message("TerminateProcess_Model\n");
	Message("[TerminateProcess_Model|evidence] {[Terminate the process with the code: %u]}\n", uExitCode);
	return TRUE;
}

static BOOL VirtualFree_Model(LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD dwFreeType)
{
	Message("VirtualFree_Model\n");
	return TRUE;
}

static BOOL VirtualProtect_Model(_In_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flNewProtect, _Out_ PDWORD lpflOldProtect)
{
	Message("VirtualProtect_Model\n");
	return TRUE;
}

static BOOL WriteFile_Model(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped)
{
	Message("WriteFile_Model\n");
	return TRUE;
}

static char* strcat_Model(char* dest, const char* src)
{
	Message("strcat_Model\n");
	return NULL;
}

static char* strcpy_Model(char* dest, const char* src)
{
	Message("strcpy_Model\n");
	return NULL;
}

static char* strrchr_Model(char* s, int c)
{
	Message("strrchr_Model\n");
	return NULL;
}

static char*** __cdecl __p___argv_Model(void)
{
	Message(" __p___argv_Model\n");
	return NULL;
}

static DWORD GetCurrentDirectoryA_Model(_In_ DWORD nBufferLength, LPSTR lpBuffer)
{
	Message("GetCurrentDirectoryA_Model\n");
	return 1;
}

static DWORD GetCurrentThreadId_Model(VOID)
{
	Message("GetCurrentThreadId_Model\n");
	return 1;
}

static DWORD GetFileAttributesA_Model(_In_ LPCSTR lpFileName)
{
	Message("GetFileAttributesA_Model\n");
	return 1;
}

static DWORD GetFileAttributesW_Model(_In_ LPCWSTR lpFileName)
{
	Message("GetFileAttributesW_Model\n");
	return 1;
}

static DWORD GetFileSize_Model(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh)
{
	Message("GetFileSize_Model\n");
	return 1;
}

static DWORD GetFileType_Model(_In_ HANDLE hFile)
{
	Message("GetFileType_Model\n");
	return 1;
}

static DWORD GetFullPathNameA_Model(_In_ LPCSTR lpFileName, _In_ DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart)
{
	Message("GetFullPathNameA_Model\n");
	return 1;
}

static DWORD GetLogicalDriveStringsA_Model(_In_ DWORD nBufferLength, LPSTR lpBuffer)
{
	Message("GetLogicalDriveStringsA_Model\n");
	return 1;
}

static DWORD GetModuleFileNameA_Model(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize)
{
	Message("GetModuleFileNameA_Model\n");
	Message("[GetModuleFileNameW_Model|info] {[APICALL]}\n");
	DWORD retVal = GetModuleFileNameA(hModule,lpFilename,nSize);
	//if (detail.compare("all") == 0)
	//{
	//	S2EMakeSymbolic(lpFilename, sizeof(nSize), "GetModuleFileNameA_Model"); /* OUT VARIABLE */
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return 1;
}

static DWORD GetModuleFileNameW_Model(_In_opt_ HMODULE hModule, LPWSTR lpFilename, _In_ DWORD nSize)
{
	Message("GetModuleFileNameW_Model\n");
	Message("[GetModuleFileNameW_Model|info] {[APICALL]}\n");
	DWORD retVal = GetModuleFileNameW(hModule, lpFilename, nSize);
	Message("[GetModuleFileNameW_Model|info] {[APICALL returns %s]}\n",CW2A(lpFilename));
	return retVal;
}

static DWORD GetShortPathNameA_Model(_In_ LPCSTR lpszLongPath, LPSTR lpszShortPath, _In_ DWORD cchBuffer)
{
	Message("GetShortPathNameA_Model\n");
	return 1;
}

static DWORD GetTempPathW_Model(_In_ DWORD nBufferLength, LPWSTR lpBuffer)
{
	Message("GetTempPathW_Model\n");
	return 1;
}

static DWORD GetTickCount_Model(VOID)
{
	Message("GetTickCount_Model\n");
	return 1;
}

static DWORD GetTimeZoneInformation_Model(_Out_ LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
{
	Message("GetTimeZoneInformation_Model\n");
	return 1;
}

static DWORD SetFilePointer_Model(_In_ HANDLE hFile, _In_ LONG lDistanceToMove, _Inout_opt_ PLONG lpDistanceToMoveHigh, _In_ DWORD dwMoveMethod)
{
	Message("SetFilePointer_Model\n");
	//Message("[SetFilePointer_Model|info] {[APICALL]}\n");
	Message("[SetFilePointer_Model|evidence] {[Move the file pointer %ld units, using the method %d]}\n", lDistanceToMove,dwMoveMethod);
	DWORD retVal = 1;//SetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh,dwMoveMethod);
	//S2EMakeSymbolic(&retVal, sizeof(retVal), "SetFilePointer_Model");
	return retVal;
}

static DWORD SizeofResource_Model(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo)
{
	Message("SizeofResource_Model\n");
	return 1;
}

static DWORD WaitForSingleObject_Model(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds)
{
	Message("WaitForSingleObject_Model\n");
	Message("[WaitForSingleObject_Model|evidence] {[Wait for %u (ms)]}\n", dwMilliseconds);
	return 1;
}

static FILE* fopen_Model(const char* filename, const char* modes)
{
	Message("fopen_Model\n");
	return fopen(filename, modes);
}

static HANDLE CreateEventA_Model(_In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCSTR lpName)
{
	Message("CreateEventA_Model\n");
	return NULL;
}

static HANDLE CreateFileA_Model(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)
{
	Message("CreateFileA_Model\n");
	return NULL;
}
static HANDLE CreateFileW_Model(_In_ LPCWSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile)
{
	Message("CreateFileW_Model\n");
	Message("[CreateFileW_Model|evidence] {[Create a file with name: '%s' with access: '0x%x']}\n",CW2A(lpFileName),dwDesiredAccess);
	//Message("[CreateFileW_Model|info] {[APICALL]}\n");
	HANDLE retVal = NULL;// CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	return retVal;
}
static HANDLE CreateFileMappingW_Model(_In_ HANDLE hFile, _In_opt_ LPSECURITY_ATTRIBUTES lpFileMappingAttributes, _In_ DWORD flProtect, _In_ DWORD dwMaximumSizeHigh, _In_ DWORD dwMaximumSizeLow, _In_opt_ LPCWSTR lpName)
{
	Message("CreateFileMappingW_Model\n");
	return NULL;
}
static BOOL CreateProcessW_Model(_In_opt_ LPCWSTR lpApplicationName, _Inout_opt_ LPWSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCWSTR lpCurrentDirectory, _In_ LPSTARTUPINFOW lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation)
{
	Message("CreateProcessW_Model\n");
	Message("[CreateProcessW_Model|evidence] {[Create process '%s' with commandline: '%s']}\n", CW2A(lpApplicationName), lpCommandLine);
	return TRUE;
}

static BOOL CryptGenKey_Model(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY  *phKey) 
{
	Message("CryptGenKey_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static BOOL CryptEncrypt_Model(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
{
	Message("CryptEncrypt_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static BOOL CryptDestroyKey_Model(HCRYPTKEY hKey)
{
	Message("CryptDestroyKey_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static BOOL CryptImportKey_Model(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
{
	Message("CryptImportKey_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static BOOL CryptAcquireContextA_Model(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
{
	Message("CryptImportKey_Model\n");
	BOOL retVal = TRUE;
	return retVal;
}

static HANDLE FindFirstFileA_Model(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData)
{
	Message("FindFirstFileA_Model\n");
	return NULL;
}

static HANDLE GetCurrentProcess_Model(VOID)
{
	Message("GetCurrentProcess_Model\n");
	return NULL;
}

static HANDLE GetProcessHeap_Model(VOID)
{
	Message("GetProcessHeap_Model\n");
	return NULL;
}

static HANDLE GetStdHandle_Model(_In_ DWORD nStdHandle)
{
	Message("GetStdHandle_Model\n");
	return NULL;
}

static HANDLE HeapCreate_Model(_In_ DWORD flOptions, _In_ SIZE_T dwInitialSize, _In_ SIZE_T dwMaximumSize)
{
	Message("HeapCreate_Model\n");
	return NULL;
}

static HANDLE OpenMutexA_Model(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCSTR lpName)
{
	Message("OpenMutexA_Model\n");
	return NULL;
}

static HGLOBAL GlobalAlloc_Model(_In_ UINT uFlags, _In_ SIZE_T dwBytes)
{
	Message("GlobalAlloc_Model\n");
	return NULL;
}

static HGLOBAL GlobalFree_Model(HGLOBAL hMem)
{
	Message("GlobalFree_Model\n");
	return NULL;
}

static HGLOBAL LoadResource_Model(_In_opt_ HMODULE hModule, _In_ HRSRC hResInfo)
{
	Message("LoadResource_Model\n");
	return NULL;
}

static HMODULE GetModuleHandleA_Model(_In_opt_ LPCSTR lpModuleName)
{
	Message("GetModuleHandleA_Model\n");
	Message("[GetModuleHandleA_Model|evidence] {[Get module handle for %s]}\n", lpModuleName);
	return NULL;
}

static HMODULE LoadLibraryA_Model(_In_ LPCSTR lpLibFileName)
{
	Message("LoadLibraryA_Model\n");
	Message("[LoadLibraryA_Model|info] {[APICALL]}\n");
	HMODULE retVal=LoadLibraryA(lpLibFileName); /* ilerlemeyi etkiledi */
	if (lpLibFileName != NULL)
	{
		Message("[LoadLibraryA_Model|evidence] {[Load the Library: %s]}\n", lpLibFileName);
	}
	return retVal;
}

static HMODULE LoadLibraryW_Model(_In_ LPCWSTR lpLibFileName)
{
	Message("LoadLibraryW_Model\n");
	return NULL;
}

static HRSRC FindResourceA_Model(_In_opt_ HMODULE hModule, _In_ LPCSTR lpName, _In_ LPCSTR lpType)
{
	Message("FindResourceA_Model\n");
	///*if (lpName != NULL) kontrol ise yaramadi, cakildi durdu. 
	//{
	//	Message("[FindResourceA_Model|evidence] {[ResourceName: %s]}\n", lpName);
	//}*
	return NULL;
}

static HRSRC FindResourceW_Model(_In_opt_ HMODULE hModule, _In_ LPCWSTR lpName, _In_ LPCWSTR lpType)
{
	Message("FindResourceW_Model\n");
	return NULL;
}

static int __cdecl _stricmp_Model(_In_z_ char const* String1, _In_z_ char const* String2)
{
	Message("__cdecl _stricmp_Model\n");
	return _stricmp(String1,String2);
}

static int _XcptFilter_Model(unsigned long xcptnum, void* pxcptinfoptrs)
{
	Message("_XcptFilter_Model\n");
	return 1;
}

static int CompareStringA_Model(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZCH lpString1, _In_ int cchCount1, PCNZCH lpString2, _In_ int cchCount2)
{
	Message("CompareStringA_Model\n");
	return 1;
}

static int CompareStringW_Model(_In_ LCID Locale, _In_ DWORD dwCmpFlags, PCNZWCH lpString1, _In_ int cchCount1, PCNZWCH lpString2, _In_ int cchCount2)
{
	Message("CompareStringW_Model\n");
	return 1;
}

static int fclose_Model(FILE* stream)
{
	Message("fclose_Model\n");
	return fclose(stream);
}

static int LCMapStringA_Model(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCSTR lpSrcStr, _In_ int cchSrc, LPSTR lpDestStr, _In_ int cchDest)
{
	Message("LCMapStringA_Model\n");
	return 1;
}

static int LCMapStringW_Model(_In_ LCID Locale, _In_ DWORD dwMapFlags, LPCWSTR lpSrcStr, _In_ int cchSrc, LPWSTR lpDestStr, _In_ int cchDest)
{
	Message("LCMapStringW_Model\n");
	return 1;
}

static int memcmp_Model(const void* s1, const void* s2, size_t n)
{
	Message("memcmp_Model\n");
	Message("[memcmp_Model|info] {[APICALL]}\n");
	Message("[memcmp_Model|evidence] {[ compare with:\n");
	for (int i = 0; i < n; i++)
	{
		Message("[memcmp_Model|evidence] 0x%x ?= 0x%x --> %c?=%c\n",((char*)s1)[i],((char*)s2)[i],((char*)s1)[i], ((char*)s2)[i]);
	}
	Message("[memcmp_Model|evidence] ]}\n");
	int retVal = memcmp(s1, s2, n);
	return retVal;
}
/*/
static int MultiByteToWideChar_Model(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar)
{
	Message("MultiByteToWideChar_Model\n");
	return 1;
}
*/
static int rand_Model(void)
{
	Message("rand_Model\n");
	return 1;
}

static int sprintf_Model(char* s, const char* format, ...)
{
	Message("sprintf_Model\n");
	return 1;
}

static int strcmp_Model(const char* s1, const char* s2)
{
	Message("strcmp_Model\n");
	return 1;
}

static int swprintf_Model(wchar_t* s, size_t n, const wchar_t* format, ...)
{
	Message("swprintf_Model\n");
	return 1;
}

/*
static int WideCharToMultiByte_Model(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCWCH lpWideCharStr, _In_ int cchWideChar, LPSTR lpMultiByteStr, _In_ int cbMultiByte, _In_opt_ LPCCH lpDefaultChar, _Out_opt_ LPBOOL lpUsedDefaultChar)
{
	Message("WideCharToMultiByte_Model\n");
	return 1;
}
*/

static int wsprintfA_Model(_Out_ LPSTR, _In_ LPCSTR, ...)
{
	Message("wsprintfA_Model\n");
	return 1;
}

static int* __cdecl __p___argc_Model(void)
{
	Message("__p___argc_Model\n");
	Message("[__p___argc_Model|info] {[APICALL]}\n");
	int* retVal = __p___argc();
	Message("[__p___argc_Model|evidence] {[Arg count: %d]}\n",*retVal);
	return retVal;
}

static int* __cdecl __p__commode_Model(void)
{
	Message("__cdecl __p__commode_Model\n");
	return NULL;
}

static int* __cdecl __p__fmode_Model(void)
{
	Message("__cdecl __p__fmode_Model\n");
	return NULL;
}

static int32_t _3f__3f_0exception_40__40_QAE_40_ABQBD_40_Z_Model(char** a1)
{
	Message("_3f__3f_0exception_40__40_QAE_40_ABQBD_40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_0exception_40__40_QAE_40_ABV0_40__40_Z_Model(int32_t* a1)
{
	Message("_3f__3f_0exception_40__40_QAE_40_ABV0_40__40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_1exception_40__40_UAE_40_XZ_Model(void)
{
	Message("_3f__3f_1exception_40__40_UAE_40_XZ_Model\n");
	return 1u;
}

static int32_t _3f__3f_1type_info_40__40_UAE_40_XZ_Model(void)
{
	Message("_3f__3f_1type_info_40__40_UAE_40_XZ_Model\n");
	return 1u;
}

static int32_t _3f__3f_2_40_YAPAXI_40_Z_Model(int32_t a1)
{
	Message("_3f__3f_2_40_YAPAXI_40_Z_Model\n");
	return 1u;
}

static int32_t _3f__3f_3_40_YAXPAX_40_Z_Model(int32_t* a1)
{
	Message("_3f__3f_3_40_YAXPAX_40_Z_Model\n");
	return 1u;
}

static LONG UnhandledExceptionFilter_Model(_In_ struct _EXCEPTION_POINTERS* ExceptionInfo)
{
	Message("UnhandledExceptionFilter_Model\n");
	return 1;
}

static LPCH GetEnvironmentStrings_Model(VOID)
{
	Message("GetEnvironmentStrings_Model\n");
	return NULL;
}

static LPSTR GetCommandLineA_Model(VOID)
{
	Message("GetCommandLineA_Model\n");
	return GetCommandLineA();
}

static LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter_Model(_In_opt_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
	Message("SetUnhandledExceptionFilter_Model\n");
	return NULL;
}

static LPVOID HeapAlloc_Model(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ SIZE_T dwBytes)
{
	Message("HeapAlloc_Model\n");
	return NULL;
}

static LPVOID HeapReAlloc_Model(_Inout_ HANDLE hHeap, _In_ DWORD dwFlags, LPVOID lpMem, _In_ SIZE_T dwBytes)
{
	Message("HeapReAlloc_Model\n");
	return NULL;
}

static LPVOID LockResource_Model(_In_ HGLOBAL hResData)
{
	Message("LockResource_Model\n");
	return NULL;
}

static LPVOID VirtualAlloc_Model(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD flAllocationType, _In_ DWORD flProtect)
{
	Message("VirtualAlloc_Model\n");
	Message("[VirtualAlloc_Model|evidence] {[Allocation size: %u, allocation type: 0x%x, protections: 0x%x]}\n", dwSize,flAllocationType,flProtect);
	Message("[VirtualAlloc_Model|info] {[APICALL]}\n");
	LPVOID retVal = VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
	// (detail.compare("all") == 0)
	//
	///S2EMakeSymbolic(&retVal, sizeof(retVal), "VirtualAlloc_Model");
	//
	//se
	//
	//* Concrete output */
	//
	return retVal;
}

static LPWCH GetEnvironmentStringsW_Model(void)
{
	Message("GetEnvironmentStringsW_Model\n");
	return NULL;
}

static LSTATUS RegCloseKey_Model(_In_ HKEY hKey)
{
	Message("RegCloseKey_Model\n");
	return 0;
}

static LSTATUS RegCreateKeyExA_Model(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition)
{
	Message("RegCreateKeyExA_Model\n");
	Message("[RegCreateKeyExA_Model|evidence] {[Name of the SubKey: %s, Options: 0x%x, AccessRights: 0x%x, CreateNew(1)orOpenExisting(2):0x%x]}\n", lpSubKey, dwOptions, samDesired, lpdwDisposition);
	return 0;
}

static LSTATUS RegCreateKeyExW_Model(_In_ HKEY hKey, _In_ LPCWSTR lpSubKey, DWORD Reserved, _In_opt_ LPWSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition)
{
	Message("RegCreateKeyExW_Model\n");
	return 0;
}

static LSTATUS RegCreateKeyW_Model(_In_ HKEY hKey, _In_opt_ LPCWSTR lpSubKey, _Out_ PHKEY phkResult)
{
	Message("RegCreateKeyW_Model\n");
	Message("[RegCreateKeyW_Model|evidence] {[Create a registry key with name: '%s']}\n", CW2A(lpSubKey));
	return 0;
}

static LSTATUS RegDeleteValueA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName)
{
	Message("RegDeleteValueA_Model\n");
	Message("[RegDeleteValueA_Model|evidence] {[Delete a registry key with name: '%s']}\n", lpValueName);
	return 0;
}

static LSTATUS RegFlushKey_Model(_In_ HKEY hKey)
{
	Message("RegFlushKey_Model\n");
	return 0;
}

static LSTATUS RegOpenKeyExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult)
{
	Message("RegOpenKeyExA_Model\n");
	Message("[RegOpenKeyExA_Model|evidence] {[Open a registry key with name: '%s']}\n", lpSubKey);
	return 0;
}

static LSTATUS RegQueryValueExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
	Message("RegQueryValueExA_Model\n");
	Message("[RegQueryValueExA_Model|evidence] {[Query a registry key with name: '%s']}\n", lpValueName);
	return 0;
}

static LSTATUS RegSetValueExA_Model(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE* lpData, _In_ DWORD cbData)
{
	Message("RegSetValueExA_Model\n");
	Message("[RegSetValueExA_Model|evidence] {[Set values of a registry key with name: '%s']}\n", lpValueName);
	Message("[RegSetValueExA_Model|evidence] {[Data written to the registery: ");
	for (int i = 0; i < cbData; i++)
	{
		Message("0x%x", lpData[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
	}
	Message("in ASCII format \"");
	for (int i = 0; i < cbData; i++)
	{
		if ((lpData[i] >= 0x22) && (lpData[i] <= 0x7E))
		{
			Message("%c", lpData[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
		}
		else
		{
			Message("[NON-ASCII]");
		}
	}
	Message("\"]}\n");
	return 0;
}

static LSTATUS RegSetValueExW_Model(_In_ HKEY hKey, _In_opt_ LPCWSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE* lpData, _In_ DWORD cbData)
{
	Message("RegSetValueExW_Model\n");
	Message("[RegSetValueExW_Model|evidence] {[Set values of a registry key with name: '%s']}\n", CW2A(lpValueName));
	Message("[RegSetValueExW_Model|evidence] {[Data written to the registery: ");
	for (int i = 0; i < cbData; i++)
	{
		Message("0x%x", lpData[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
	}
	Message("in ASCII format \"");
	for (int i = 0; i < cbData; i++)
	{
		if ((lpData[i] >= 0x22) && (lpData[i] <= 0x7E))
		{
			Message("%c", lpData[i]); /* ToDo: ASCII olarak da yazdir. (Opsiyonel) */
		}
		else
		{
			Message("[NON-ASCII]");
		}
	}
	Message("\"]}\n");
	return 0;
}

#pragma warning(disable : 4996)
static NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExA_Model(_Inout_ LPOSVERSIONINFOA lpVersionInformation)
{
	Message("GetVersionExA_Model\n");
	Message("[GetVersionExA_Model|info] {[APICALL]}\n");
	BOOL retVal = GetVersionExA(lpVersionInformation);
	return retVal;
}

static NOT_BUILD_WINDOWS_DEPRECATE DWORD GetVersion_Model(VOID)
{
	Message("GetVersion_Model\n");
	Message("[GetVersion_Model|info] {[APICALL]}\n");
	DWORD retVal = GetVersion();
	return retVal;
}

static PVOID FreeSid_Model(_In_ PSID pSid)
{
	Message("FreeSid_Model\n");
	return NULL;
}

static SC_HANDLE CreateServiceA_Model(_In_ SC_HANDLE hSCManager, _In_ LPCSTR lpServiceName, _In_opt_ LPCSTR lpDisplayName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwServiceType, _In_ DWORD dwStartType, _In_ DWORD dwErrorControl, _In_opt_ LPCSTR lpBinaryPathName, _In_opt_ LPCSTR lpLoadOrderGroup, _Out_opt_ LPDWORD lpdwTagId, _In_opt_ LPCSTR lpDependencies, _In_opt_ LPCSTR lpServiceStartName, _In_opt_ LPCSTR lpPassword)
{
	Message("CreateServiceA_Model\n");
	return NULL;
}

static SC_HANDLE OpenSCManagerA_Model(_In_opt_ LPCSTR lpMachineName, _In_opt_ LPCSTR lpDatabaseName, _In_ DWORD dwDesiredAccess)
{
	Message("OpenSCManagerA_Model\n");
	return NULL;
}

static SC_HANDLE OpenServiceA_Model(_In_ SC_HANDLE hSCManager, _In_ LPCSTR lpServiceName, _In_ DWORD dwDesiredAccess)
{
	Message("OpenServiceA_Model\n");
	return NULL;
}

static size_t fread_Model(void* ptr, size_t size, size_t n, FILE* stream)
{
	Message("fread_Model\n");
	return 1;
}

static size_t fwrite_Model(const void* ptr, size_t size, size_t n, FILE* s)
{
	Message("fwrite_Model\n");
	Message("[fwrite_Model|info] {[APICALL]}\n");
	size_t retVal = fwrite(ptr, size, n, s);
	return retVal;
}

static SIZE_T HeapSize_Model(_In_ HANDLE hHeap, _In_ DWORD dwFlags, _In_ LPCVOID lpMem)
{
	Message("HeapSize_Model\n");
	return 1;
}

static size_t strlen_Model(const char* s)
{
	Message("strlen_Model\n");
	return 1;
}

static size_t wcslen_Model(const wchar_t* s)
{
	Message("wcslen_Model\n");
	return 1;
}

static UINT GetACP_Model(void)
{
	Message("GetACP_Model\n");
	return 1u;
}

static UINT GetDriveTypeA_Model(_In_opt_ LPCSTR lpRootPathName)
{
	Message("GetDriveTypeA_Model\n");
	return 1u;
}

static UINT GetOEMCP_Model(void)
{
	Message("GetOEMCP_Model\n");
	return 1u;
}

static UINT GetWindowsDirectoryA_Model(LPSTR lpBuffer, _In_ UINT uSize)
{
	Message("GetWindowsDirectoryA_Model\n");
	return 1u;
}

static UINT GetWindowsDirectoryW_Model(LPWSTR lpBuffer, _In_ UINT uSize)
{
	Message("GetWindowsDirectoryW_Model\n");
	return 1u;
}

static UINT SetHandleCount_Model(_In_ UINT uNumber)
{
	Message("SetHandleCount_Model\n");
	return 1u;
}

static unsigned char _CONST_RETURN* __cdecl _mbsstr_Model(_In_z_ unsigned char const* Str, _In_z_ unsigned char const* Substr)
{
	Message("char _CONST_RETURN* __cdecl _mbsstr_Model\n");
	return 0; /* Hopefully types continues with int, char..etc. */
}

static unsigned int __cdecl _controlfp_Model(_In_ unsigned int NewValue, _In_ unsigned int Mask)
{
	Message("int __cdecl _controlfp_Model\n");
	return 1u; /* Hopefully types continues with int, char..etc. */
}

static void __set_app_type_Model(int at)
{
	Message("__set_app_type_Model\n");
	return;
}

static VOID DeleteCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("DeleteCriticalSection_Model\n");
	return;
}

static VOID EnterCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("EnterCriticalSection_Model\n");
	return;
}

static void exit_Model(int status)
{
	Message("exit_Model\n");
	Message("[exit_Model|info] {[APICALL]}\n");
	Message("[exit_Model|evidence] {[Status: %d]}\n",status);
	exit(status);
	return;
}

static VOID ExitProcess_Model(_In_ UINT uExitCode)
{
	Message("ExitProcess_Model\n");
	Message("[ExitProcess_Model|info] {[APICALL]}\n");
	Message("[ExitProcess_Model|evidence] {[Exit Code: %u]}\n", uExitCode);
	ExitProcess(uExitCode);
	return;
}

static void free_Model(void* ptr)
{
	Message("free_Model\n");
	Message("[free_Model|info] {[APICALL]}\n");
	free(ptr);
	return;
}

static VOID GetStartupInfoA_Model(_Out_ LPSTARTUPINFOA lpStartupInfo)
{
	Message("GetStartupInfoA_Model\n");
	Message("[GetStartupInfoA_Model|info] {[APICALL]}\n");
	GetStartupInfoA(lpStartupInfo);
	//if (detail.compare("all") == 0)
	//{
	//	//S2EMakeSymbolic(lpStartupInfo, sizeof(_STARTUPINFOA), "GetStartupInfoA_Model"); /* OUT VARIABLE */ /* Inanýlmaz yoruyor. */
	//}
	//else
	//{
	//	/* Concrete output */
	//}
	return;
}

static VOID GetSystemInfo_Model(_Out_ LPSYSTEM_INFO lpSystemInfo)
{
	Message("GetSystemInfo_Model\n");
	Message("[GetStartupInfoA_Model|info] {[SYMBOLIC]}\n");
	memset(lpSystemInfo,0,sizeof(_SYSTEM_INFO)); // have better result readability
	S2EMakeSymbolic(lpSystemInfo, sizeof(_SYSTEM_INFO), "SystemInfo");
	return;
}

static VOID GetSystemTime_Model(_Out_ LPSYSTEMTIME lpSystemTime)
{
	Message("GetSystemTime_Model\n");
	return;
}

static VOID InitializeCriticalSection_Model(_Out_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("InitializeCriticalSection_Model\n");
	return;
}

static VOID LeaveCriticalSection_Model(_Inout_ LPCRITICAL_SECTION lpCriticalSection)
{
	Message("LeaveCriticalSection_Model\n");
	return;
}

static VOID OutputDebugStringA_Model(_In_opt_ LPCSTR lpOutputString)
{
	Message("OutputDebugStringA_Model\n");
	return;
}

static VOID RtlUnwind_Model(_In_opt_ PVOID TargetFrame, _In_opt_ PVOID TargetIp, _In_opt_ PEXCEPTION_RECORD ExceptionRecord, _In_ PVOID ReturnValue)
{
	Message("RtlUnwind_Model\n");
	return;
}

static VOID SetLastError_Model(_In_ DWORD dwErrCode)
{
	Message("SetLastError_Model\n");
	Message("[SetLastError_Model|info] {[APICALL]}\n");
	Message("[SetLastError_Model|evidence] {[Error Code: %d]}\n",dwErrCode);
	SetLastError(dwErrCode);
	return;
}

static VOID Sleep_Model(_In_ DWORD dwMilliseconds)
{
	Message("Sleep_Model\n");
	return;
}

static void srand_Model(unsigned int seed)
{
	Message("srand_Model\n");
	Message("[srand_Model|info] {[APICALL]}\n");
	Message("[srand_Model|evidence] {[Seed: %u]}\n", seed);
	srand(seed);
	return;
}
/*
static void* calloc_Model(size_t nmemb, size_t size)
{
	Message("calloc_Model\n");
	Message("[calloc_Model|info] {[APICALL]}\n");
	Message("[calloc_Model|evidence] {[size: %u]}\n", size);
	return calloc(nmemb,size);
}
*/

static void* malloc_Model(size_t size)
{
	Message("malloc_Model\n");
	Message("[malloc_Model|info] {[APICALL]}\n");
	Message("[malloc_Model|evidence] {[size: %u]}\n", size);
	return malloc(size);
}
static LPVOID MapViewOfFile_Model(_In_ HANDLE hFileMappingObject, _In_ DWORD dwDesiredAccess, _In_ DWORD dwFileOffsetHigh, _In_ DWORD dwFileOffsetLow, _In_ SIZE_T dwNumberOfBytesToMap)
{
	Message("MapViewOfFile_Model\n");
	return NULL;
}
static void* memcpy_Model(void* dest, const void* src, size_t n)
{
	Message("memcpy_Model\n");
	Message("[memcpy_Model|info] {[APICALL]}\n");
	Message("[memcpy_Model|evidence] {[Copy files with size %u. Its content:\n", n);
	for (int i = 0; i < n; i++)
	{
		Message("0x%x (%c)", ((char*)src)[i], ((char*)src)[i]);
	}
	Message("]}\n");
	return memcpy(dest, src, n);;
}

static void* memset_Model(void* s, int c, size_t n)
{
	Message("memset_Model\n");
	Message("[memset_Model|info] {[APICALL]}\n");
	Message("[memset_Model|evidence] {[fill the memory with %d %d's ]}\n", n,c);
	return memset(s, c, n);;
}

static void* realloc_Model(void* ptr, size_t size)
{
	Message("realloc_Model\n");
	Message("[realloc_Model|info] {[APICALL]}\n");
	Message("[realloc_Model|evidence] {[size: %u]}\n", size);
	return realloc(ptr,size);
}

static wchar_t* wcscat_Model(wchar_t* dest, const wchar_t* src)
{
	Message("wcscat_Model\n");
	return NULL;
}

static wchar_t* wcsrchr_Model(wchar_t* wcs, wchar_t wc)
{
	Message("wcsrchr_Model\n");
	return wcsrchr(wcs,wc);
}


/* ---------------------------------------- MODELS END ---------------------------------------- */

// The names of the functions to hook (and the library they belong to)
static LPCSTR functionsToHook[][2] = {
	{"ucrtbase.dll","__stdio_common_vfprintf" },
	{"ucrtbase.dll","__stdio_common_vfscanf" },
	{"ucrtbase.dll","__p___argc" },
	{"ucrtbase.dll","__p___argv" },
	{"ucrtbase.dll","_stricmp" },
	//{"ucrtbase.dll","calloc" },
	{"Kernel32.dll","CloseHandle" },
	{"Advapi32.dll","CloseServiceHandle" },
	{"Kernel32.dll","CopyFileA" },
	{"Kernel32.dll","CompareStringA" },
	{"Kernel32.dll","CompareStringW" },
	{"Kernel32.dll","CreateEventA" },
	{"Kernel32.dll","CreateFileA" },
	{"Kernel32.dll","CreateFileW" },
	{"Kernel32.dll","CreateFileMappingW"},
	{"Kernel32.dll","CreateProcessW" },
	{"Kernel32.dll","CreateDirectoryA" },
	{"Kernel32.dll","CreateDirectoryW" },
	{"Kernel32.dll","CreateProcessA" },
	{"Advapi32.dll","CryptReleaseContext" },
	{"Advapi32.dll","CryptGenKey" },
	{"Advapi32.dll","CryptEncrypt" },
	{"Advapi32.dll","CryptDestroyKey" },
	{"Advapi32.dll","CryptImportKey" },
	{"Advapi32.dll","CryptAcquireContextA" },
	{"Kernel32.dll","CreateRemoteThread" },
	{"Advapi32.dll","CreateServiceA" },
	{"Kernel32.dll","CreateToolhelp32Snapshot" },
	{"Kernel32.dll","DeleteFileW" },
	//{"Kernel32.dll","DeleteCriticalSection" }, /* bad */			/* supheli */
	//{"Kernel32.dll","EnterCriticalSection" },						/* supheli */
	{"ucrtbase.dll","exit" },
	{"Kernel32.dll","ExitProcess" },
	{"ucrtbase.dll","fclose" },
	{"Kernel32.dll","FindFirstFileA" },
	{"Kernel32.dll","FindResourceA" },
	{"Kernel32.dll","FindResourceW" },
	{"ucrtbase.dll","fopen" },
	{"Kernel32.dll","FormatMessageW" },
	{"ucrtbase.dll","fread" },
	{"ucrtbase.dll","free" },
	{"Kernel32.dll","FreeEnvironmentStringsA" },
	{"Kernel32.dll","FreeEnvironmentStringsW" },
	{"Kernel32.dll","FreeLibrary" },
	{"Advapi32.dll","FreeSid" },
	{"ucrtbase.dll","fwrite" },
	{"Kernel32.dll","GetACP" },
	{"ucrtbase.dll","getchar" },
	{"Kernel32.dll","GetCommandLineA" },
	{"Kernel32.dll","GetComputerNameW" },
	{"Kernel32.dll","GetCPInfo" },
	{"Kernel32.dll","GetCurrentDirectoryA" },
	//{"Kernel32.dll","GetCurrentProcess" },			/* supheli */
	//{"Kernel32.dll","GetCurrentThreadId" },			/* supheli */
	{"Kernel32.dll","GetDriveTypeA" },
	{"Kernel32.dll","GetEnvironmentStrings" },
	{"Kernel32.dll","GetEnvironmentStringsW" },
	{"Kernel32.dll","GetExitCodeProcess" },
	{"Kernel32.dll","GetFileAttributesA" },
	{"Kernel32.dll","GetFileAttributesW" },
	{"Kernel32.dll","GetFileSize" },
	{"Kernel32.dll","GetFileSizeEx" },
	{"Kernel32.dll","GetFileType" },
	{"Kernel32.dll","GetFullPathNameA" },
	{"Kernel32.dll","GetLastError" },
	{"Kernel32.dll","GetLocalTime" },
	{"Kernel32.dll","GetLogicalDriveStringsA" },
	{"Kernel32.dll","GetModuleFileNameA" },
	{"Kernel32.dll","GetModuleFileNameW" },
	{"Kernel32.dll","GetModuleHandleA" },
	{"Kernel32.dll","GetModuleHandleW" },
	{"Kernel32.dll","GetOEMCP" },
	{"Kernel32.dll","GetPriorityClass" },
	{"Kernel32.dll","GetProcAddress" },
	{"Kernel32.dll","GetProcessId" },
	{"Kernel32.dll","GetProcessHeap" },
	{"Kernel32.dll","GetShortPathNameA" },
	{"Kernel32.dll","GetStartupInfoA" }, /*galiba*/
	{"Kernel32.dll","GetStdHandle" },
	{"Kernel32.dll","GetStringTypeA" },
	{"Kernel32.dll","GetStringTypeW" },
	{"Kernel32.dll","GetSystemInfo" },
	{"Kernel32.dll","GetSystemTime" },
	{"Kernel32.dll","GetTempPathW" },
	{"Kernel32.dll","GetTickCount" },
	{"Kernel32.dll","GetTimeZoneInformation" },
	{"Advapi32.dll","GetTokenInformation" },
	{"Kernel32.dll","GetVersion" },
	{"Kernel32.dll","GetVersionExA" },
	{"Kernel32.dll","GetWindowsDirectoryA" },
	{"Kernel32.dll","GetWindowsDirectoryW" },
	//{"Kernel32.dll","GlobalAlloc" },				  /* supheli */
	//{"Kernel32.dll","GlobalFree" },				  /* supheli */
	//{"Kernel32.dll","HeapAlloc" },				  /* supheli */
	//{"Kernel32.dll","HeapCreate" },				  /* supheli */
	//{"Kernel32.dll","HeapDestroy" },				  /* supheli */
	//{"Kernel32.dll","HeapFree" },					  /* supheli */
	//{"Kernel32.dll","HeapReAlloc" },				  /* supheli */
	//{"Kernel32.dll","HeapSize" },					  /* supheli */
	//{"Kernel32.dll","InitializeCriticalSection" },  /* supheli */
	{"Kernel32.dll","IsBadCodePtr" },
	{"Kernel32.dll","IsBadReadPtr" },
	{"Kernel32.dll","IsBadWritePtr" },
	{"Kernel32.dll","LCMapStringA" },
	{"Kernel32.dll","LCMapStringW" },
	//{"Kernel32.dll","LeaveCriticalSection" },			/* supheli */
	{"Kernel32.dll","LoadLibraryA" },
	{"Kernel32.dll","LoadLibraryW" },
	{"Kernel32.dll","LoadResource" },
	{"Kernel32.dll","LocalFileTimeToFileTime" },
	{"Kernel32.dll","LockResource" },
	//{"Kernel32.dll","LookupPrivilegeValueA" }, /* wrong lib */
	{"ucrtbase.dll","malloc" },
	{"Kernel32.dll","MapViewOfFile" },
	{"ucrtbase.dll","memcmp" },
	//{"ucrtbase.dll","memcpy" }, /* cok log olusturdu. */
	{"ucrtbase.dll","memset" },
	{"Kernel32.dll","MoveFileA" },
	{"Kernel32.dll","MoveFileExA" },
	//{"Kernel32.dll","MultiByteToWideChar" },
	//{"Kernel32.dll","OpenMutexA" },			/* supheli */
	{"Kernel32.dll","OpenProcess" },
	{"Advapi32.dll","OpenProcessToken" },
	{"Advapi32.dll","OpenSCManagerA" },
	{"Advapi32.dll","OpenServiceA" },
	{"Kernel32.dll","OpenThread" },
	{"Kernel32.dll","OutputDebugStringA" },
	{"Kernel32.dll","Process32FirstW" },
	{"Kernel32.dll","Process32NextW" },
	{"Kernel32.dll","QueryPerformanceCounter" },
	{"Kernel32.dll","QueryPerformanceFrequency" },
	{"Advapi32.dll","QueryServiceStatus" },
	{"ucrtbase.dll","rand" },
	{"Kernel32.dll","ReadFile" },
	{"ucrtbase.dll","realloc" },
	{"Advapi32.dll","RegCloseKey" },
	{"Advapi32.dll","RegCreateKeyExA" },
	{"Advapi32.dll","RegCreateKeyExW" },
	{"Advapi32.dll","RegCreateKeyW" },
	{"Advapi32.dll","RegDeleteValueA" },
	{"Advapi32.dll","RegFlushKey" },
	{"Advapi32.dll","RegOpenKeyExA" },
	{"Advapi32.dll","RegQueryValueExA" },
	{"Advapi32.dll","RegSetValueExA" },
	{"Advapi32.dll","RegSetValueExW" },
	{"Kernel32.dll","ResumeThread" },
	//{"Kernel32.dll","RtlUnwind" },			/* supheli */
	{"Kernel32.dll","SetConsoleCtrlHandler" },
	{"Kernel32.dll","SetCurrentDirectoryA" },
	{"Kernel32.dll","SetCurrentDirectoryW" },
	{"Kernel32.dll","SetEndOfFile" },
	{"Kernel32.dll","SetEnvironmentVariableA" },
	{"Kernel32.dll","SetFileAttributesA" },
	{"Kernel32.dll","SetFileAttributesW" },
	{"Kernel32.dll","SetFilePointer" },
	{"Kernel32.dll","SetFileTime" },
	{"Kernel32.dll","SetHandleCount" },
	{"Kernel32.dll","SetLastError" },
	{"Kernel32.dll","SetStdHandle" },
	//{"Kernel32.dll","SetUnhandledExceptionFilter" },			/* supheli */
	{"Kernel32.dll","SizeofResource" },
	{"Kernel32.dll","Sleep" },
	//{"ucrtbase.dll","sprintf" }, /* wrong lib */
	{"ucrtbase.dll","srand" },
	{"Advapi32.dll","StartServiceA" },
	{"ucrtbase.dll","strcat" },
	{"ucrtbase.dll","strcmp" },
	{"ucrtbase.dll","strcpy" },
	{"ucrtbase.dll","strlen" },
	{"ucrtbase.dll","wcslen" },
	//{"ucrtbase.dll","strrchr" },
	{"Kernel32.dll","SuspendThread" },
	{"Kernel32.dll","SHGetSpecialFolderPathA" },
	//{"ucrtbase.dll","swprintf" }, /* wrong lib */
	{"Kernel32.dll","SystemTimeToFileTime" },
	{"Kernel32.dll","TerminateProcess" },
	{"Kernel32.dll","Thread32First" },
	{"Kernel32.dll","Thread32Next" },
	{"Kernel32.dll","UnhandledExceptionFilter" },
	{"Kernel32.dll","VirtualAlloc" },
	{"Kernel32.dll","VirtualAllocEx" },
	{"Kernel32.dll","VirtualFree" },
	{"Kernel32.dll","VirtualProtect" },
	{"Kernel32.dll","WaitForSingleObject" },
	//{"Kernel32.dll","WideCharToMultiByte" },
	{"Kernel32.dll","WriteFile" },
	{"Kernel32.dll","WriteProcessMemory" },
	//{"User32.dll","wsprintfA" },
	{ NULL, NULL },
};

// The function hooks that we will install
static PVOID hookFunctions[] = {
	__stdio_common_vfprintf_Model,
	__stdio_common_vfscanf_Model,
	__p___argc_Model,
	__p___argv_Model,
	_stricmp_Model,
	//calloc_Model,
	CloseHandle_Model,
	CloseServiceHandle_Model,
	CopyFileA_Model,
	CompareStringA_Model,
	CompareStringW_Model,
	CreateEventA_Model,
	CreateFileA_Model,
	CreateFileW_Model,
	CreateFileMappingW_Model,
	CreateProcessW_Model,
	CreateDirectoryA_Model,
	CreateDirectoryW_Model,
	CreateProcessA_Model,
	CryptReleaseContext_Model,
	CryptGenKey_Model,
	CryptEncrypt_Model,
	CryptDestroyKey_Model,
	CryptImportKey_Model,
	CryptAcquireContextA_Model,
	CreateRemoteThread_Model,
	CreateServiceA_Model,
	CreateToolhelp32Snapshot_Model,
	DeleteFileW_Model,
	//DeleteCriticalSection_Model,			/* supheli */
	//EnterCriticalSection_Model,			/* supheli */
	exit_Model,
	ExitProcess_Model,
	fclose_Model,
	FindFirstFileA_Model,
	FindResourceA_Model,
	FindResourceW_Model,
	fopen_Model,
	FormatMessageW_Model,
	fread_Model,
	free_Model,
	FreeEnvironmentStringsA_Model,
	FreeEnvironmentStringsW_Model,
	FreeLibrary_Model,
	FreeSid_Model,
	fwrite_Model,
	GetACP_Model,
	getchar_Model,
	GetCommandLineA_Model,
	GetComputerNameW_Model,
	GetCPInfo_Model,
	GetCurrentDirectoryA_Model,
	//GetCurrentProcess_Model,			/* supheli */
	//GetCurrentThreadId_Model,			/* supheli */
	GetDriveTypeA_Model,
	GetEnvironmentStrings_Model,
	GetEnvironmentStringsW_Model,
	GetExitCodeProcess_Model,
	GetFileAttributesA_Model,
	GetFileAttributesW_Model,
	GetFileSize_Model,
	GetFileSizeEx_Model,
	GetFileType_Model,
	GetFullPathNameA_Model,
	GetLastError_Model,
	GetLocalTime_Model,
	GetLogicalDriveStringsA_Model,
	GetModuleFileNameA_Model,
	GetModuleFileNameW_Model,
	GetModuleHandleA_Model,
	GetModuleHandleW_Model,
	GetOEMCP_Model,
	GetPriorityClass_Model,
	GetProcAddress_Model,
	GetProcessId_Model,
	GetProcessHeap_Model,
	GetShortPathNameA_Model,
	GetStartupInfoA_Model,
	GetStdHandle_Model,
	GetStringTypeA_Model,
	GetStringTypeW_Model,
	GetSystemInfo_Model,
	GetSystemTime_Model,
	GetTempPathW_Model,
	GetTickCount_Model,
	GetTimeZoneInformation_Model,
	GetTokenInformation_Model,
	GetVersion_Model,
	GetVersionExA_Model,
	GetWindowsDirectoryA_Model,
	GetWindowsDirectoryW_Model,
	//GlobalAlloc_Model,						/* supheli */
	//GlobalFree_Model,							/* supheli */
	//HeapAlloc_Model,							/* supheli */
	//HeapCreate_Model,							/* supheli */
	//HeapDestroy_Model,						/* supheli */
	//HeapFree_Model,							/* supheli */
	//HeapReAlloc_Model,						/* supheli */
	//HeapSize_Model,							/* supheli */
	//InitializeCriticalSection_Model,			/* supheli */
	IsBadCodePtr_Model,
	IsBadReadPtr_Model,
	IsBadWritePtr_Model,
	LCMapStringA_Model,
	LCMapStringW_Model,
	//LeaveCriticalSection_Model,				/* supheli */	
	LoadLibraryA_Model,
	LoadLibraryW_Model,
	LoadResource_Model,
	LocalFileTimeToFileTime_Model,
	LockResource_Model,
	//LookupPrivilegeValueA_Model,				/* supheli */
	MapViewOfFile_Model,
	malloc_Model,
	memcmp_Model,
	//memcpy_Model, /* cok log olusturdu */		/* supheli */
	memset_Model,
	MoveFileA_Model,
	MoveFileExA_Model,
	//MultiByteToWideChar_Model,
	//OpenMutexA_Model,							/* supheli */
	OpenProcess_Model,
	OpenProcessToken_Model,
	OpenSCManagerA_Model,
	OpenServiceA_Model,
	OpenThread_Model,
	OutputDebugStringA_Model,
	Process32FirstW_Model,
	Process32NextW_Model,
	QueryPerformanceCounter_Model,
	QueryPerformanceFrequency_Model,
	QueryServiceStatus_Model,
	rand_Model,
	ReadFile_Model,
	realloc_Model,
	RegCloseKey_Model,
	RegCreateKeyExA_Model,
	RegCreateKeyExW_Model,
	RegCreateKeyW_Model,
	RegDeleteValueA_Model,
	RegFlushKey_Model,
	RegOpenKeyExA_Model,
	RegQueryValueExA_Model,
	RegSetValueExA_Model,
	RegSetValueExW_Model,
	ResumeThread_Model,
	//RtlUnwind_Model,							/* supheli */
	SetConsoleCtrlHandler_Model,
	SetCurrentDirectoryA_Model,
	SetCurrentDirectoryW_Model,
	SetEndOfFile_Model,
	SetEnvironmentVariableA_Model,
	SetFileAttributesA_Model,
	SetFileAttributesW_Model,
	SetFilePointer_Model,
	SetFileTime_Model,
	SetHandleCount_Model,
	SetLastError_Model,
	SetStdHandle_Model,
	//SetUnhandledExceptionFilter_Model, 			/* supheli */
	SizeofResource_Model,
	Sleep_Model,
	//sprintf_Model, /* wrong lib */				/* supheli */
	srand_Model,
	StartServiceA_Model,
	strcat_Model,
	strcmp_Model,
	strcpy_Model,
	strlen_Model,
	wcslen_Model,
	//strrchr_Model,								/* supheli */
	SuspendThread_Model,
	SHGetSpecialFolderPathA_Model,
	//swprintf_Model,								/* supheli */
	SystemTimeToFileTime_Model,
	TerminateProcess_Model,
	Thread32First_Model,
	Thread32Next_Model,
	UnhandledExceptionFilter_Model,
	VirtualAlloc_Model,
	VirtualAllocEx_Model,
	VirtualFree_Model,
	VirtualProtect_Model,
	WaitForSingleObject_Model,
	//WideCharToMultiByte_Model,
	WriteFile_Model,
	WriteProcessMemory_Model,
	////wsprintfA_Model,
};

// The actual hooks
static HOOK_TRACE_INFO hooks[] = {
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
	{ NULL },
};

// EasyHook will be looking for this export to support DLL injection. If not
// found then DLL injection will fail
extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO *);

void __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO *inRemoteInfo)
{
	// Unused
	(void *)inRemoteInfo;
	// Used by the Message function to decide where to write output to
	s2eVersion = S2EGetVersion();

	/* Get detail level */
	ifstream detailFile("trigger.txt"); //open

	while (getline(detailFile, detail)) // read
	{
		Message(detail.c_str()); // log
	}

	detailFile.close(); //close


	// TODO initialize hooks
	// Replace the previous TODO with the following code to install the
	// GetLocalTime hook
	Message("Hooks will start.\n");
	for (unsigned i = 0; functionsToHook[i][0] != NULL; ++i)
	{
		LPCSTR moduleName = functionsToHook[i][0];
		LPCSTR functionName = functionsToHook[i][1];

		// Install the hook
		NTSTATUS result = LhInstallHook(
			GetProcAddress(GetModuleHandleA(moduleName), functionName),
			hookFunctions[i],
			NULL,
			&hooks[i]);

		if (FAILED(result))
		{
			Message("Failed to hook %s.%s: %S at %d\n", moduleName, functionName,
				RtlGetLastErrorString(), i);
		}
		else
		{
			Message("Successfully hooked %s.%s at %d\n", moduleName, functionName, i);
		}

		// Ensure that all threads _except_ the injector thread will be hooked
		ULONG ACLEntries[1] = { 0 };
		LhSetExclusiveACL(ACLEntries, 1, &hooks[i]);
	}
	Message("Hooks end.\n");
	// The process was started in a suspended state. Wake it up...
	RhWakeUpProcess();
}
