// malware-inject.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <fstream>
#include <Shlwapi.h>
#include <Windows.h>

#include <easyhook.h>
#if _WIN64
#pragma comment(lib, "EasyHook64.lib")
#else
#pragma comment(lib, "EasyHook32.lib")
#endif

#pragma comment(lib, "libcommon.lib")


// We must add this header file to support writing to S2E's logs. s2e.h resides
// in the libcommon project, so the libcommon project must be added as a
// dependency to the malware-inject project
#define USER_APP
#include <s2e/s2e.h>

#define S2E_MSG_LEN 512
#define MAX_PATH_LEN 256

static INT s2eVersion = 0;

static void Message(LPCSTR fmt, ...) {
	CHAR message[S2E_MSG_LEN];
	va_list args;

	va_start(args, fmt);
	vsnprintf(message, S2E_MSG_LEN, fmt, args);
	va_end(args);

	if (s2eVersion) {
		S2EMessageFmt("[Injector] %s", message);
	}
	else {
		printf("[Injector] %s", message);
	}
}

static void GetFullPath(LPCWSTR path, PWCHAR fullPath) {
	if (!path) {
		Message("Path has not been provided\n");
		exit(1);
	}

	if (!PathFileExistsW(path)) {
		Message("Invalid path %S has been provided\n", path);
		exit(1);
	}

	if (!GetFullPathNameW(path, MAX_PATH_LEN, fullPath, NULL)) {
		Message("Unable to get full path of %S\n", path);
		exit(1);
	}
}

int main() {
	Message("running\n");
	INT argc;
	LPWSTR *argv = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argc < 5) {
		Message("Usage: %S [options..]\n"
			"   --dll <dll>       Path to DLL to inject into the application\n"
			"   --app <target>    Path to application to start\n"
			"   --timeout <time>  Timeout value in milliseconds "
			"(infinite if not provided)\n", argv[0]);
		Message("Current argc: %d\n", argc);
		exit(1);
	}

	// Used by the Message function to decide where to write output to
	Message("S2E uncomment yap!\n");
	//s2eVersion = S2EGetVersion();
	Message("Done\n");
	LPWSTR dllPath = NULL;
	WCHAR fullDllPath[MAX_PATH_LEN];

	LPWSTR appPath = NULL;
	WCHAR fullAppPath[MAX_PATH_LEN];

	LPWSTR trigger = NULL;

	DWORD timeout = INFINITE;

	Message("Parse\n");
	for (int i = 1; i < argc; ++i) {
		if (wcscmp(argv[i], L"--dll") == 0) {
			Message("DLL parsed.\n");
			dllPath = argv[++i];
			continue;
		}

		if (wcscmp(argv[i], L"--app") == 0) {
			Message("App parsed.\n");
			appPath = argv[++i];
			continue;
		}


		if (wcscmp(argv[i], L"--trigger") == 0) {
			Message("Trigger parsed.\n");
			trigger = argv[++i];
			continue;
		}


		if (wcscmp(argv[i], L"--timeout") == 0) {
			Message("Timeout parsed.\n");
			timeout = wcstoul(argv[++i], NULL, 10);
			continue;
		}

		Message("Unsupported argument: %s\n", argv[i]);
		exit(1);
	}


	std::ofstream MyFile("trigger.txt");

	if (wcscmp(trigger, L"all") == 0)
	{
		Message("All trigers will be activated!\n");
		MyFile << "all";
	}
	else
	{
		Message("No trigger will be given!\n");
		MyFile << "none";
	}

	// Close the file
	MyFile.close();

	// Check that the given paths are valid
	GetFullPath(dllPath, fullDllPath);
	GetFullPath(appPath, fullAppPath);

	// Start the target application (in a suspended state) and inject the given
	// DLL
	ULONG pid;
	//WCHAR symbolic_input[32];
	//S2EMakeSymbolic(symbolic_input, sizeof(symbolic_input), "symbolic_input");
	NTSTATUS result = RhCreateAndInject(appPath, L"123", CREATE_SUSPENDED,
		EASYHOOK_INJECT_DEFAULT,
#if defined(_M_IX86)
		dllPath, NULL,
#elif defined(_M_X64)
		NULL, dllPath,
#else
#error "Platform not supported"
#endif
		NULL, 0, &pid);

	if (FAILED(result)) {
		Message("RhCreateAndInject failed: %S\n", RtlGetLastErrorString());
		exit(1);
	}

	Message("Successfully injected %S into %S (PID=0x%x)\n", fullDllPath,
		fullAppPath, pid);

	DWORD exitCode = 1;

	// Get a handle to the newly-created process and wait for it to terminate.
	// Once the process has terminated, get its return code and return that as
	// our return code
	HANDLE hProcess = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,
		FALSE, pid);
	if (hProcess) {
		WaitForSingleObject(hProcess, timeout);
		GetExitCodeProcess(hProcess, &exitCode);
		CloseHandle(hProcess);
	}
	else {
		Message("Unable to open process 0x%x: 0x%X\n", pid, GetLastError());
	}

	return exitCode;
}

